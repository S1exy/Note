

## 2 .3 亚克星上的军队
题目：


## 3.7 火车
~~~python
import sys

  
n = int(sys.stdin.readline())
input_train = sys.stdin.readline().strip()
input_train = list(map(int,input_train)) 
output_train = sys.stdin.readline().strip()
output_train = list(map(int,output_train))
stack = []
record = []
idx = 0

  

for train in input_train:

    stack.append(train)

    record.append("in")

  

    while stack and stack[-1] == output_train[idx]:

        stack.pop()
        record.append("out")
        idx += 1 

if stack:
    print("No")
else:
    print("Yes")
    for re in record:
        print(re)
~~~
## 3.8 价值

~~~python
import sys

  

n = sys.stdin.readline()

  

data = sys.stdin.readline().split()

  

data = list(map(int,data)) + [-1]

  
  

# data = [3,1,6,4,5,2,-1]

# # 前缀和

num = [0] * (len(data) + 1)

  

for i in range(len(data)):

    num[i+1] = data[i] + num[i]

stack = []

ans = 0

  

for i in range(len(data)):

    while stack and data[stack[-1]] >= data[i]:

        temper = stack.pop()

        left = stack[-1] if stack else -1

        iii = num[i] - num[left+1]

        ans = max(ans,data[temper] * iii)

    stack.append(i)

print(ans)
~~~


## 魔音吉他




## bfs

~~~python
import sys

import heapq

  

a = sys.stdin.readline().split()

n,m = map(int,a)

  

grid = []

start_x , start_y = 0 , 0

  

for i in range(n):

    row = sys.stdin.readline().strip()

    grid.append(row)

  

    if "r" in row:

        start_x = i

        start_y = row.find("r")

  
  

inf = float("inf")

  

dist = [[inf] * m for _ in range(n)]

dist[start_x][start_y] = 0

  

pq = [(0,start_x,start_y)]

  

directions = [(-1,0),(1,0),(0,-1),(0,1)]

  

found = False

  

while pq:

    d,x,y = heapq.heappop(pq)

  

    if d >dist[x][y]:

        continue

  

    if grid[x][y] == "a":

        print(d)

        found = True

        break

  

    for dx,dy in directions:

        nx = x + dx

        ny = y + dy

  

        if 0<=nx < n and 0<= ny < m and grid[nx][ny]!= "#":

            weight = 2 if grid[nx][ny] =="x" else 1

            new_dist = d + weight

  

            if new_dist < dist[nx][ny]:

                dist[nx][ny] = new_dist

                heapq.heappush(pq,(new_dist,nx,ny))

  

if not found:

    print(-1)
~~~

## 鼹鼠报数


~~~python
import sys


  

def dfs(nums):

    if not nums: return ""

  

    root = nums[-1]

  

    mid = 0

    # 找分界点

    while mid < len(nums) - 1 and nums[mid] < root:

        mid += 1

  

    res = str(root)

  

    # 处理左子树

    left = dfs(nums[:mid])

    if left:

        res += f"<{left}>"

  

    # 处理右子树

    right = dfs(nums[mid:-1])

    # 【错误 1 & 2 修改】

    # 原代码写成了 if left (判断错变量) 

    # 原代码写成了 "<right>" (只是个字符串，不是变量值)

    if right:

        res += f"<{right}>"  # 必须加花括号 {} 才是取变量的值

  

    return res

  

# 【错误 3 修改】

# sys 模块没有 readline 方法，必须是 sys.stdin.readline

# 第一行是 N，读了但不处理

sys.stdin.readline() 

  

# 第二行才是数字

data = sys.stdin.readline().split()

  

if data:

    print(dfs([int(x) for x in data]))
~~~