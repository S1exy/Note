# 奇怪的算法笔记

来源自算法随想录 & leetcode 记录一下小小采集的算法成长之路，虽然是不打算走算法这一条道路 但是算法还是非常的奇幻和玄妙啊



## 数组的操作：

### 1.二分查找

`bisect`python中可以通过调用这个包的形式进行直接的二分计算，我就先不进行实践了

### 2.移除元素

###### （1）[26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

在这道题中我们就是采用了双指针的方法，通过一快一慢的两个指针分别指向有的和没有的重复的项，从而实现进行移除元素的操作

```python
class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """

        slow, fast = 0, 1
        while fast < len(nums):
            if nums[fast] != nums[slow]:
                slow = slow + 1
                nums[slow] = nums[fast]
            fast = fast + 1
        return slow + 1
```

![27.移除元素-双指针法](https://gitee.com/Slexy/picture/raw/master/20250413112436722.gif)

这个是一个比较简单的图示，代表着快慢指针的操作过程通过一快一慢的方法进行操作（当然了这边示范的是进行删除固定元素的操作）

在上面的这道题题目给出的条件是，递增序列除去相同的元素，但是如果不是递增序列呢，可以通过维护一个数组的方法来进行记录已经出现过的元素（我本来的方法？ 放在下面作为一个参考：

```python
class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        # 用于记录已经出现过的元素
        seen = set()
        # 慢指针，记录不重复元素的位置
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] not in seen:
                # 将不重复元素放到慢指针位置
                nums[slow] = nums[fast]
                # 记录该元素已出现
                seen.add(nums[fast])
                # 慢指针后移一位
                slow += 1
        return slow
```



###### （2）[283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/)

这道题我尝试了双指针的方法，不知道该怎么具体的去做，后面我思考了一下，就使用了最傻傻的方法，循环暴力求解，可以看下我的代码

```python
class Solution(object):
    def moveZeroes(self, nums):
        """
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        
        slow = 0
        for slow in range(0,len(nums)):
            if nums[slow] == 0:
                for fast in range(slow + 1,len(nums)):
                    if nums[fast] != 0:
                        temper  = nums[slow]
                        nums[slow] = nums[fast]
                        nums[fast] = temper
                        break
```

然后去看了大佬的题解，用一个类似于双指针的方法，解决了这个问题，确实太过于巧妙了，我在下面一步步的解析他的思路：

```python
class Solution(object):
	def moveZeroes(self, nums):
		"""
		:type nums: List[int]
		:rtype: None Do not return anything, modify nums in-place instead.
		"""
		if not nums:
			return 0
        
		# 第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]	
		
        j = 0
		for i in xrange(len(nums)):
			if nums[i]:
				nums[j] = nums[i]
				j += 1
                
		# 非0元素统计完了，剩下的都是0了
		# 所以第二次遍历把末尾的元素都赋为0即可
		for i in xrange(j,len(nums)):
			nums[i] = 0

```

第一段的代码可以看成是，如果num[i] == 0 就跳过他，然后快指针快速扫过去把所有的不是0 的全部放到前面去，然后同时也可以记录下有几个0，最后一次性来处理所有的0放在最后面去（实在是过于巧妙了，牛逼！）

<img src="https://gitee.com/Slexy/picture/raw/master/20250413113726913.gif" alt="283_1.gif" style="zoom:33%;" />



###### （3）[844. 比较含退格的字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/backspace-string-compare/)

这道题我刚看到我就开始想是不是可以使用倒序的字符串操作，从后往前然后把两个字符串构造出来，最后再进行比对，这个的时间复杂度是 `（m + n）` ：

```
class Solution(object):
    def backspaceCompare(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """

        s = s[::-1]
        s1 = ""
        z = 0
        for k in s:
            if k == "#":
                z += 1
            elif z != 0:
                z -= 1
            else:
                s1 += k
        s = s1[::-1]

        t = t[::-1]
        t1 = ""
        z = 0
        for k in t:
            if k == "#":
                z += 1
            elif z != 0:
                z -= 1
            else:
                t1 += k
        t = t1[::-1]

        return t == s
```

然后我去看了一下大佬的思路，其实并不需要怎么麻烦去模仿栈的思路，其实可以简单一点，只需要一个个去对比就可以了

这个方法就是从后往前的双指针法：

下面是他的实现粗略图，不过我觉得没有非常的必要进行具体的复现，我就先放在这里了，）偷个懒

![844.比较含退格的字符串.gif](https://gitee.com/Slexy/picture/raw/master/20250413121153374.gif)



















































