**cs231n笔记**

[TOC]

# assignment1

## 1.k-Nearest Neighbor classifier：

[CS231n Convolutional Neural Networks for Visual Recognition](https://cs231n.github.io/classification/)       ~~课程链接~~

### （1）引入部分

​	首先引入了图像分类（Image Classification）的概念告诉我们图像分类主要是做什么的并且举例如何去实现它，例如下图通过对图片的识别从而构建分类器推算分类的概率<img src="https://gitee.com/Slexy/picture/raw/master/20250224231340832.png" alt="image-20250224231340738" style="zoom: 67%;" />

### （2）K-最近分类器（K-Nearest Neighbor Classifier）

​	最近分类器的主要方法就是通过比较图像的每个像素差异，然后找到最相近的图像，通过最近的图像来判断输入需要判断的图像的类别，基于此他主要的过程实现就有如下几点：

- 首先是训练模型（其实不需要，因为模型的本身就是训练集）
- 然后是输入测试集（test）然后计算测试集对于每个训练集的图像的像素差异值，课程中主要提到的有两种方法L1和L2方法，具体的实现放在代码部分
- 然后通过找到的最小的差异值来确定测试的图片属于哪个类别



#### A.代码实现

##### 1.数据的预处理：

```python
# 定位数据集的位置
cifar10_dir = 'cs231n/datasets/cifar-10-batches-py'

# 清理变量以防止多次加载数据 (这可能导致内存问题)（主要是用于在nptebook中因为在
# nootbook中可能会多次调用其中一个代码框
try:
   del X_train, y_train
   del X_test, y_test
   print('Clear previously loaded data.')
except:
   pass

X_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir)

# 作为一种检查，打印出训练和测试数据的大小。
print('Training data shape: ', X_train.shape)
print('Training labels shape: ', y_train.shape)
print('Test data shape: ', X_test.shape)
print('Test labels shape: ', y_test.shape)

# 输出结果:
# Clear previously loaded data.
# Training data shape:  (50000, 32, 32, 3)
# Training labels shape:  (50000,)
# Test data shape:  (10000, 32, 32, 3)
# Test labels shape:  (10000,)
```



##### 2.对于输入数据的可视化

下面给出代码和每一个部分的详解

```python
# 可视化部分的数据
classes = ['plane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck']
num_classes = len(classes)
samples_per_class = 7
for y, cls in enumerate(classes):
    idxs = np.flatnonzero(y_train == y)
    idxs = np.random.choice(idxs, samples_per_class, replace=False)
    for i, idx in enumerate(idxs):
        plt_idx = i * num_classes + y + 1
        plt.subplot(samples_per_class, num_classes, plt_idx)
        plt.imshow(X_train[idx].astype('uint8'))
        plt.axis('off')
        if i == 0:
            plt.title(cls)
plt.show()
```

1. 代码中`classes`代表着数据集中图片的种类名称，`num_classes`计算出种类的个数（在后面的输出图片的位置计算中有用，`samples_per_class`定义了每个种类显示出几张图片。

   

2. `enumerate()` 是 Python 中的一个内置函数，用于将一个可迭代对象（如列表、元组、字符串等）组合为一个索引序列，同时列出数据和数据下标。所以`for y, cls in enumerate(classes):`这段代码将类的索引划分给`y`，类名划分给`cls`。

   

3. `np.flatnonzero(a)` 是 NumPy 库中的一个函数，它用于找出数组中非零元素的索引。这个函数将多维数组展平成一维数组，然后找出所有非零元素的索引。`a`：输入的 NumPy 数组。返回一个一维数组，包含输入数组中所有非零元素的索引。

   `idxs = np.flatnonzero(y_train == y)`所以这一段代码的作用是找出所有在循环中同类的训练集的行，并返回其的索引值。其次注意`y_train == y`这段代码实则是在找到同类的行，前者则是输出这些行在训练集中的索引

   

4. `numpy.random.choice(a, size=None, replace=True, p=None)`是 NumPy 库中的一个函数，用于从给定的一维数组中随机选择元素。

   **参数说明：**

   - `a`：输入的一维数组，从中随机选择元素。

   - `size`（可选）：输出数组的大小。如果为 `None`（默认值），则返回单个随机选择的元素。如果为整数，返回一个包含 `size` 个随机选择元素的数组。如果为元组，返回一个形状为 `size` 的多维数组。

   - `replace`（可选）：布尔值，表示是否允许重复选择同一个元素。默认为 `True`，表示允许重复选择。如果为 `False`，则不允许重复选择，这相当于无放回抽样。

   - `p`（可选）：一个与数组 `a` 大小相同的一维概率数组，表示选择每个元素的概率。如果为 `None`（默认值），则假设每个元素被选择的概率相等。

   返回一个数组，包含从输入数组 `a` 中随机选择的元素。

   ​	所以`np.random.choice(idxs, samples_per_class, replace=False)`的作用是从上文中得到的在训练集中的索引再通过`samples_per_class`随机不重复的选择出几个索引传入`idxs`

   

5. `plt_idx = i * num_classes + y + 1`计算出每个图像的坐标索引参数，具体计算需要做出的结果大概如下：

   <img src="https://gitee.com/Slexy/picture/raw/master/20250224234624691.png" alt="image-20250224234624640" style="zoom:67%;" />

   **需要的注意的是**：这个索引是从1开始的所以应该+1来确保索引的正确性

   

6. `plt.subplot` 是 Matplotlib 库中用于创建子图（subplot）的函数。子图是指在单个图形窗口中创建多个小图，这些小图可以并排显示或以网格形式排列。`plt.subplot` 允许你指定子图的行数、列数以及当前激活的子图索引。

   **参数说明：**

   - `nrows`：子图的行数。

   - `ncols`：子图的列数。

   - `index`：当前激活的子图索引，从 1 开始。这个索引确定了子图在网格中的位置。

   所以该处使用了 `plt.subplot(samples_per_class, num_classes, plt_idx)` 来创建小图的一个边框？？（应该是吧）

   

   `plt.imshow(X_train[idx].astype('uint8'))`接下来就是在训练集中使用前文得到的索引来进行图片的输出了，使用`uint8`进行输出得到图片

   `plt.axis('off')`同时取消图片上的坐标轴使其变的更美观

   `if i == 0: plt.title(cls)`最后别忘了输出每一类的标题哦
   最终的成品

   <img src="https://gitee.com/Slexy/picture/raw/master/20250224235322536.png" alt="image-20250224235322433" style="zoom:67%;" />

   

   **较好的展示了整个数据集的图片大致情况**



##### 3.调整数据集格式以适应训练过程

- 确定训练集的个数和测试集的个数

```python
# Subsample the data for more efficient code execution in this exercise
num_training = 5000
mask = list(range(num_training))
X_train = X_train[mask]
y_train = y_train[mask]

num_test = 500
mask = list(range(num_test))
X_test = X_test[mask]
y_test = y_test[mask]
```



- 调整训练集和测试集图像的像素点，使其排列在同一行上形成类似于(500, 3072)的样式

```python
# Reshape the image data into rows
X_train = np.reshape(X_train, (X_train.shape[0], -1))
X_test = np.reshape(X_test, (X_test.shape[0], -1))
print(X_train.shape, X_test.shape)
```



##### 4.构建分类器并开始进行预测和训练

```python
classifier = KNearestNeighbor()
classifier.train(X_train, y_train)
```

这其中包含了 `KNearestNeighbor()`这一个类其中包含了以下几个函数：

- train()

  

  ```python
  def train(self, X, y):
      self.X_train = X
      self.y_train = y
      
  ```

​		其中`X`和`y`分别是训练集的像素数据和训练集的图像对应		的标签

- predict()

  

  ```python
  predict(self, X, k=1, num_loops=0):
      if num_loops == 0:
          dists = self.compute_distances_no_loops(X)
      elif num_loops == 1:
          dists = self.compute_distances_one_loop(X)
      elif num_loops == 2:
          dists = self.compute_distances_two_loops(X)
      else:
          raise ValueError("Invalid value %d for num_loops" % num_loops)
  
      return self.predict_labels(dists, k=k)
  ```

  其中 `X` 是需要判断的测试集

  `k`为为预测标签投票的最近邻居的数目。

- compute_distances_no_loops(self, X):

  

  ```python
  compute_distances_no_loops(self, X):
      num_test = X.shape[0]
      num_train = self.X_train.shape[0]
      dists = np.zeros((num_test, num_train))
      y=self.X_train.transpose();
      temp=X.dot(y)
      temp=temp*2
      x2=np.sum(np.square(X),axis=1).reshape(-1,1)
      y2=np.sum(np.square(y),axis=0).reshape(1,-1)
      c=x2+y2
      temp=c-temp      
      dists=temp
      pass
  
  return dists
  ```

  同样的输入一个测试集 从上文中的 `predict()`传入然后进行计算他和训练集的距离：

  其中有两种公式：（分别是L1和L2公式这个**knn训练采用的是L2计算方法**）

  1. <img src="https://gitee.com/Slexy/picture/raw/master/20250225193602079.png" alt="image-20250225193602011" style="zoom:50%;" />
  2. <img src="https://gitee.com/Slexy/picture/raw/master/20250225193556620.png" style="zoom:50%;" />

- predict_labels()

  

  ```python
  def predict_labels(self, dists, k=1):
      num_test = dists.shape[0]
      y_pred = np.zeros(num_test)
      for i in range(num_test):
        
          closest_y = []
       
          temp=np.argsort(dists[i])[:k]
          closest_y=self.y_train[temp]
  
  
          unique,count=np.unique(closest_y,return_counts=True)
          data_count=dict(zip(unique,count))
          d=sorted(data_count,key=lambda x:data_count[x],reverse=True)       
          y_pred[i]=d[0]
  	return y_pred
  ```

  同样附属于`predict()`函数 其中作用为返回一个测试集所对应的标签类别的一个列表array。

  解释内容：

  <img src="https://gitee.com/Slexy/picture/raw/master/20250225194721059.png" alt="image-20250225194720874" style="zoom:50%;" />

#### B.部分内容的解释

- 首先是loops的选择经过计算和验证之后可以得到loops应该选择0，即直接对矩阵进行运算而不是抽出来一个个运算，他们的运算时间如下可以见到，我们可以发现当loops = 0 时地速度显著的高于其他二者

  ![image-20250225195145345](https://gitee.com/Slexy/picture/raw/master/20250225195145420.png)

#### C.交叉验证确认k的选择

```python
num_folds = 5
k_choices = [1, 3, 5, 8, 10, 12, 15, 20, 50, 100]

X_train_folds = []
y_train_folds = []


X_train_folds = (np.array_split(X_train , num_folds ,axis= 0))
y_train_folds = (np.array_split(y_train , num_folds ,axis= 0))


k_to_accuracies = {}



for k in k_choices:
  k_to_accuracies[k]=[]
  for i in range(num_folds):
    index=[j for j in range(num_folds) if j!= i]

    temp_x_train=np.concatenate([X_train_folds[j] for j in index])
    temp_y_train=np.concatenate([y_train_folds[j] for j in index])
    classifier = KNearestNeighbor()
    classifier.train(temp_x_train, temp_y_train)
    temp_y_test_pred=classifier.predict(X_train_folds[i],k,num_loops=0)
    correct=np.sum(temp_y_test_pred==y_train_folds[i])
    k_to_accuracies[k].append(correct/y_train_folds[i].shape[0])
pass


for k in sorted(k_to_accuracies):
    for accuracy in k_to_accuracies[k]:
        print('k = %d, accuracy = %f' % (k, accuracy))
```

代码解释：

- `num_folds`代表分类的个数即平均分为几类

- `k_choices`不必解释这个就是k的可能取值

- `X_train_folds = []  y_train_folds = []` 这两个列表用来储存分割后的数据集和对应的标签

- `X_train_folds = (np.array_split(X_train , num_folds ,axis= 0))`这段代码和下面那一段同样的是用来均等的分割数据集返回一个列表将其赋给前面定义的列表

- `k_to_accuracies = {}`创建一个用于储存不同的k对应的准确度的一个字典

- ```python
  for k in k_choices:
    k_to_accuracies[k]=[]
    for i in range(num_folds):
      index=[j for j in range(num_folds) if j!= i]
      # print([X_train_folds[j] for j in index])
      temp_x_train=np.concatenate([X_train_folds[j] for j in index])
      temp_y_train=np.concatenate([y_train_folds[j] for j in index])
      classifier = KNearestNeighbor()
      classifier.train(temp_x_train, temp_y_train)
      temp_y_test_pred=classifier.predict(X_train_folds[i],k,num_loops=0)
      correct=np.sum(temp_y_test_pred==y_train_folds[i])
      k_to_accuracies[k].append(correct/y_train_folds[i].shape[0])
  pass
  ```

  对交叉训练的几个不同的k分别进行训练并将结果储存在刚刚定义的 `k_to_accuracies`中

- ```python
  for k in sorted(k_to_accuracies):
      for accuracy in k_to_accuracies[k]:
          print('k = %d, accuracy = %f' % (k, accuracy))
  ```

  输出类似于如下形式的准确度数据：

  <img src="https://gitee.com/Slexy/picture/raw/master/20250225200025500.png" alt="image-20250225200025408" style="zoom: 67%;" />



同样的我们也可以进行一波绘图更直观的展示我们的验证结果并且选取最优的k值

```python
# plot the raw observations
for k in k_choices:
    accuracies = k_to_accuracies[k]
    plt.scatter([k] * len(accuracies), accuracies)

# plot the trend line with error bars that correspond to standard deviation
accuracies_mean = np.array([np.mean(v) for k,v in sorted(k_to_accuracies.items())])
accuracies_std = np.array([np.std(v) for k,v in sorted(k_to_accuracies.items())])
plt.errorbar(k_choices, accuracies_mean, yerr=accuracies_std)
plt.title('Cross-validation on k')
plt.xlabel('k')
plt.ylabel('Cross-validation accuracy')
plt.show()
```

代码解释：

- `plt.scatter([k] * len(accuracies), accuracies)`绘制一个散点图前者为x坐标 后者为y坐标

- `plt.errorbar(k_choices, accuracies_mean, yerr=accuracies_std)`绘制带有误差条的折线图

  其中参数分别是x轴数据（列表），y轴的数据（列表），标准差（列表）

最终可以画出比较直观的图像：

<img src="https://gitee.com/Slexy/picture/raw/master/20250225200650518.png" alt="image-20250225200650446" style="zoom: 50%;" />

我们从图中可以比较直观的看出最好的k的取值应该是 k = 3

## 2.Training a Support Vector Machine（训练一个支持向量机）

------

**Linear Classification（线性分类器）**：

​	相比于knn的模型，线性分类器和其他的卷积神经网络强调训练的过程，训练得到的参数可以直接用于后续的应用识别

​	创建一个线性分类器我们需要：

### A.理论部分

#### 1.创建一个关于图像和标签分数的映射（map）

<img src="https://gitee.com/Slexy/picture/raw/master/20250308151856511.png" alt="image-20250308151856413" style="zoom:50%;" />

​	其中X = （N，D+1） W = （D+1，C）

​	其中 N为数据的个数，D为像素点展平的个数（在 CIFAR-10 中 为 32 x 32 x 3 = 3072 pixels），C为最终分类的个数

<img src="https://gitee.com/Slexy/picture/raw/master/20250308152344902.png" alt="image-20250308152344744" style="zoom:50%;" />

计算的过程大致如上

线性分类器最终得到的一个可视化大概如下

<img src="https://gitee.com/Slexy/picture/raw/master/20250308152505152.png" alt="image-20250308152504898" style="zoom:50%;" />

其中：

​	改变 W 的数值可以让分类的线进行旋转 ， 改变 bias 的数值，则是让分类的线进行平移的操作 （其中，当b = 0 时 这条分类的直线始终穿过原点）

​	因为我们不希望学习两次权重矩阵，故将b放置在W的最后一列，X矩阵增加一行1用于计算b即可

​	所以我们可以将它转换为下面的公式：

<img src="https://gitee.com/Slexy/picture/raw/master/20250308152824538.png" alt="image-20250308152824469" style="zoom:50%;" />

<img src="https://gitee.com/Slexy/picture/raw/master/20250308152921109.png" alt="image-20250308152921037" style="zoom:50%;" />

​	左边是原本的计算公式，而右边的是经过优化过后的权重矩阵和原始数据矩阵

#### 2.图像数据的预处理（Image data preprocessing）

​	可以对图像的数据进行标准化，例如在下面的代码中，将使用从每个特征中减去数据的平均值来进行集中数据，以进行零均值中心的处理，利于我们后续进行梯度下降的处理

#### 3.损失函数（Loss fuction）

​	本次代码构建中，将使用多级支持向量机损失(Multiclass Support Vector Machine loss)进行损失函数的构建，用于衡量预测结果和真实结果的偏差程度

<img src="https://gitee.com/Slexy/picture/raw/master/20250308153834827.png" alt="image-20250308153834692" style="zoom:50%;" />

​	这个loss也叫   **hinge loss** （折页损失）

​	这个是关于每一项数据的loss，假设目前我们现在有一条训练数据，当预测分数不属于label的时候，计算loss，并且需要当预测的分数和真实的分数的偏差小于 **△** （这个 △ 是一个超参数，可以根据实际情况进行调整，在下面的代码中这个 △ 的取值是 1 ）的时候才需要进行计算。

​	例如在同一行的数据中 score = [13 ， -7 ， 11] ， 13是正确标签的分数，则：

<img src="https://gitee.com/Slexy/picture/raw/master/20250308155413008.png" alt="image-20250308155412956" style="zoom:50%;" />

则： Li = 0 + 8 

第一个由于两个的分数差异大，所以他的loss计算为0，而第二个他们两个的差异相近，故计算loss为 8 。

图解：

<img src="https://gitee.com/Slexy/picture/raw/master/20250308155958412.png" alt="image-20250308155958266" style="zoom:50%;" />

​	他只有在delta范围内的损失才会被计算入总损失中，而绿色的数据和正确的分类分数相差大，则不会被计算入损失之中

**正则化**（**Regularization**)

​	在上面的loss计算中会出现一个问题就是对于同一组的数据，相同的loss可能会出现多种的W符合要求，在一些极端的情况下甚至可能出现存在W使得loss = 0 ，但是这是在训练集上的数据而非在所有的应用环境下侧得到的。

​	在这么多的W上，我们希望W在每一个参数上的权重尽可能小，这样的话在相同loss的情况下，更多的像素点参数会被纳入计算分类的过程中而不是在几个像素点上的参数非常大，导致他的鲁棒性不足。

​	所以我们引入了一个 λ 用于惩罚那些 W 的参数过大的一些组合，他可以表示为：

<img src="https://gitee.com/Slexy/picture/raw/master/20250308160551004.png" alt="image-20250308160550946" style="zoom:50%;" />

所以我们最后构造出来的一个损失函数的总和为：

<img src="https://gitee.com/Slexy/picture/raw/master/20250308160719926.png" alt="image-20250308160719805" style="zoom:50%;" />



### B.代码部分

主要分为如下的几个部分：

<img src="https://gitee.com/Slexy/picture/raw/master/20250308161126222.png" alt="image-20250308161126114" style="zoom:50%;" />

#### 1.数据的预处理

大致参考同[knn的数据预处理](#1.数据的预处理：)

并且需要加入：

```python
# second: subtract the mean image from train and test data
X_train -= mean_image
X_val -= mean_image
X_test -= mean_image
X_dev -= mean_image

# 和上文相同用于将所有的数据划分到以零为中心

# third: append the bias dimension of ones (i.e. bias trick) so that our SVM
# only has to worry about optimizing a single weight matrix W.
X_train = np.hstack([X_train, np.ones((X_train.shape[0], 1))])
X_val = np.hstack([X_val, np.ones((X_val.shape[0], 1))])
X_test = np.hstack([X_test, np.ones((X_test.shape[0], 1))])
X_dev = np.hstack([X_dev, np.ones((X_dev.shape[0], 1))])

# 在数据集的最后添加一行用于bias 设置为1

print(X_train.shape, X_val.shape, X_test.shape, X_dev.shape)
```



#### 2.构建SVM Classifier

##### （1）计算loss:

```python
def svm_loss_vectorized(W, X, y, reg):
    loss = 0.0	
    score = X.dot(W)  # (500, 10)
    correct_class_score = score[np.arange(X.shape[0]), y].reshape(-1, 1)  # (500, 1)
    margins = np.maximum(0, score - correct_class_score + 1)  # (500, 10)
    margins[np.arange(X.shape[0]), y] = 0  # (500, 10)
    loss = np.sum(margins) / X.shape[0] + reg * np.sum(W * W)



```

##### （2）计算dW:

延续计算loss的部分：

```python
mask = (margins > 0).astype(float)  # (500, 10)
    mask[np.arange(X.shape[0]), y] = -np.sum(mask, axis=1)  # (500, 10)
    dW = X.T.dot(mask) / X.shape[0] + reg * W  # (3073, 10)


    pass

    return loss, dW
```

并且通过计算我们可以发现：

<img src="https://gitee.com/Slexy/picture/raw/master/20250309135640641.png" alt="image-20250309135640558" style="zoom: 50%;" />

使用向量计算法比直接计算的方法可以高效的节省时间和计算资源

##### （3）对进入的数据进行处理并且调用loss进行计算：

```python
num_train, dim = X.shape
num_classes = (
    np.max(y) + 1

    if self.W is None:
    # lazily initialize W
    self.W = 0.001 * np.random.randn(dim, num_classes)

    # Run stochastic gradient descent to optimize W
    loss_history = []
    for it in range(num_iters):
    X_batch = None
    y_batch = None
    indices = np.random.choice(X.shape[0],size=batch_size,replace=False)

    X_batch = X[indices,:]
    y_batch = y[indices,]
    pass
    loss, grad = self.loss(X_batch, y_batch, reg)
    loss_history.append(loss)



    self.W -= grad * learning_rate
    pass


    if verbose and it % 100 == 0:
    	print("iteration %d / %d: loss %f" % (it, num_iters, loss))

    return loss_history
```

##### （4）输出预测的结果：

返回的值是预测的类别的值：

```python
def predict(self, X):
        """
        Use the trained weights of this linear classifier to predict labels for
        data points.

        Inputs:
        - X: A numpy array of shape (N, D) containing training data; there are N
          training samples each of dimension D.

        Returns:
        - y_pred: Predicted labels for the data in X. y_pred is a 1-dimensional
          array of length N, and each element is an integer giving the predicted
          class.
        """
        y_pred = np.zeros(X.shape[0])
       
        result = np.dot(X,self.W)
        y_pred = np.argmax(result,axis=1)
        pass


        return y_pred
```

根据以上的结果我们可以训练出像这样子的图像：

<img src="data:image/png;base64,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YnTv3t1Yt25dq39nvz0THOfdd8f78/5d3521zzA47x2FIuVHnn32WaNHjx5GSEiIMWbMGGP58uVmR+rUJB319fLLL3u3qaurM375y18aMTExRnh4uPGjH/3IKCoqavU5e/fuNS688EIjLCzMiI+PN26//Xajqampg4+m8/pukeKct58PP/zQGDJkiGG3242BAwcaL730Uqv1Ho/HuP/++42kpCTDbrcb559/vrFt27ZW2xw8eNC44oorjMjISMPhcBjXXXedUVVV1ZGH0am4XC7jlltuMXr06GGEhoYavXv3Nu69995Wv0hy3k/d559/ftS/z6dNm2YYRtud4/Xr1xtnnHGGYbfbjW7duhmPPvpoRx2iX/q+875nz55j/jv7+eefez+D8+674/15/66jFSnOe8ewGMa3Hr8OAAAAADgu7pECAAAAAB9RpAAAAADARxQpAAAAAPARRQoAAAAAfESRAgAAAAAfUaQAAAAAwEcUKQAAAADwEUUKANBp9erVS0899ZTZMdrNnDlzFB0dbXYMAMBRUKQAAMd17bXX6rLLLvO+P+ecczRz5swO+/5jFYpVq1bpxhtv7LAcAAAcRpECAJimsbHxlPZPSEhQeHh4G6XpOpqamsyOAACdHkUKAOCTa6+9VosXL9bTTz8ti8Uii8WivXv3SpI2btyoCy+8UJGRkUpKStLVV1+tsrIy777nnHOObr75Zs2cOVPx8fGaOHGiJOmJJ55QZmamIiIilJaWpl/+8peqrq6WJH3xxRe67rrrVFlZ6f2+3//+95KOvLQvLy9Pl156qSIjI+VwOPTTn/5UJSUl3vW///3vNXz4cL3yyivq1auXnE6npkyZoqqqqmMe7+HRsAULFmjQoEGKjIzUBRdcoKKiolbH9d0Russuu0zXXnut932vXr30xz/+Uddcc40iIyPVs2dPffDBBzpw4IA389ChQ7V69eojMrz33nvq16+fQkNDNXHiROXn57da//7772vkyJEKDQ1V79699Yc//EHNzc3e9RaLRS+++KIuueQSRURE6OGHHz7m8QIATgxFCgDgk6efflpZWVn6xS9+oaKiIhUVFSktLU0VFRU677zzNGLECK1evVrz589XSUmJfvrTn7baf+7cuQoJCdHSpUs1e/ZsSZLVatUzzzyjTZs2ae7cufrss8/0m9/8RpJ0+umn66mnnpLD4fB+3x133HFELo/Ho0svvVTl5eVavHixFi5cqN27d+tnP/tZq+127dql9957T/PmzdO8efO0ePFiPfroo997zLW1tfrzn/+sV155RV9++aXy8vKOmuF4nnzySY0fP15r167VpEmTdPXVV+uaa67RVVddpTVr1qhPnz665pprZBhGq+9++OGH9c9//lNLly5VRUWFpkyZ4l3/1Vdf6ZprrtEtt9yizZs3669//avmzJlzRFn6/e9/rx/96EfasGGDrr/+ep+zAwC+wwAA4DimTZtmXHrppd73Z599tnHLLbe02uahhx4yJkyY0GpZfn6+IcnYtm2bd78RI0Yc9/vefvttIy4uzvv+5ZdfNpxO5xHb9ezZ03jyyScNwzCMTz75xLDZbEZeXp53/aZNmwxJxsqVKw3DMIzf/e53Rnh4uOFyubzb3HnnncbYsWOPmeXll182JBk7d+70Lnv++eeNpKQk7/ujnY9LL73UmDZtWqusV111lfd9UVGRIcm4//77vctycnIMSUZRUVGr716+fLl3my1bthiSjBUrVhiGYRjnn3++8cgjj7T67ldeecVISUnxvpdkzJw585jHCADwXZB5FQ4AEEjWr1+vzz//XJGRkUes27Vrl/r37y9JGjVq1BHrP/30U82aNUtbt26Vy+VSc3Oz6uvrVVtbe8L3QG3ZskVpaWlKS0vzLsvIyFB0dLS2bNmi0047TVLLJXZRUVHebVJSUlRaWvq9nx0eHq4+ffr4tM/RDB061PtzUlKSJCkzM/OIZaWlpUpOTpYkBQUFebNL0sCBA73HNGbMGK1fv15Lly5tNQLldruPOH+jR4/2OS8A4NgoUgCANlFdXa0f/vCHeuyxx45Yl5KS4v05IiKi1bq9e/fq4osv1vTp0/Xwww8rNjZWS5Ys0Q033KDGxsY2n0wiODi41XuLxSKPx+PzPsa3Lr+zWq2t3ktHn9Dh259jsViOuex4eb6turpaf/jDH3T55ZcfsS40NNT783fPOwDg1FCkAAA+CwkJkdvtbrVs5MiR+s9//qNevXopKOjE/3nJzc2Vx+PRX/7yF1mtLbfuvvXWW8f9vu8aNGiQ8vPzlZ+f7x2V2rx5syoqKpSRkXHCeU5GQkJCq8kn3G63Nm7cqHPPPfeUP7u5uVmrV6/WmDFjJEnbtm1TRUWFBg0aJKnlvG/btk19+/Y95e8CAJw4JpsAAPisV69eWrFihfbu3auysjJ5PB7NmDFD5eXluuKKK7Rq1Srt2rVLCxYs0HXXXfe9Jahv375qamrSs88+q927d+uVV17xTkLx7e+rrq7WokWLVFZWptra2iM+Jzs7W5mZmZo6darWrFmjlStX6pprrtHZZ5/d7pe1nXfeefrvf/+r//73v9q6daumT5+uioqKNvns4OBg/epXv9KKFSuUm5ura6+9VuPGjfMWqwceeED//Oc/9Yc//EGbNm3Sli1b9Oabb+q+++5rk+8HABwdRQoA4LM77rhDNptNGRkZSkhIUF5enlJTU7V06VK53W5NmDBBmZmZmjlzpqKjo70jTUczbNgwPfHEE3rsscc0ZMgQvfbaa5o1a1arbU4//XTddNNN+tnPfqaEhAQ9/vjjR3yOxWLR+++/r5iYGJ111lnKzs5W79699a9//avNj/+7rr/+ek2bNs1b3Hr37t0mo1FSy/1Zd911l6688kqNHz9ekZGRrY5p4sSJmjdvnj755BOddtppGjdunJ588kn17NmzTb4fAHB0FuO7F3UDAAAAAL4XI1IAAAAA4COKFAAAAAD4iCIFAAAAAD6iSAEAAACAjyhSAAAAAOAjihQAAAAA+IgiBQAAAAA+okgBAAAAgI8oUgAAAADgI4oUAAAAAPiIIgUAAAAAPqJIAQAAAICP/j/BlxlUN5330AAAAABJRU5ErkJggg==" alt="img" style="zoom:50%;" />

#### C.对超参数的一些探讨：

```python
learning_rates = [1e-7, 5e-7, 5e-5, 1e-3]
regularization_strengths = [2.5e4, 5e4]


for lr in learning_rates:
  for reg in regularization_strengths:
      # 创建一个线性 SVM 对象
      svm = LinearSVM()

      # 训练模型
      tic = time.time()
      loss_hist = svm.train(X_train, y_train, lr, reg, num_iters=1500, verbose=True)
      toc = time.time()
      print('That took %fs' % (toc - tic))

      # 计算训练集准确率
      y_train_pred = svm.predict(X_train)
      train_accuracy = np.mean(y_train == y_train_pred)
      print('training accuracy: %f' % train_accuracy)

      # 计算验证集准确率
      y_val_pred = svm.predict(X_val)
      val_accuracy = np.mean(y_val == y_val_pred)
      print('validation accuracy: %f' % val_accuracy)

      # 将结果存储到字典中
      results[(lr, reg)] = (train_accuracy, val_accuracy)

      # 更新最佳模型和最佳验证准确率
      if val_accuracy > best_val:
          best_val = val_accuracy
          best_svm = svm






pass

# *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****

# Print out results.
for lr, reg in sorted(results):
    train_accuracy, val_accuracy = results[(lr, reg)]
    print('lr %e reg %e train accuracy: %f val accuracy: %f' % (
                lr, reg, train_accuracy, val_accuracy))

print('best validation accuracy achieved during cross-validation: %f' % best_val)
```



最终还可以画出一个训练出的模型的图像（他所认为的一个最适合的图像）

```python
# Visualize the learned weights for each class.
# Depending on your choice of learning rate and regularization strength, these may
# or may not be nice to look at.
w = best_svm.W[:-1,:] # strip out the bias
w = w.reshape(32, 32, 3, 10)
w_min, w_max = np.min(w), np.max(w)
classes = ['plane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck']
for i in range(10):
    plt.subplot(2, 5, i + 1)

    # Rescale the weights to be between 0 and 255
    wimg = 255.0 * (w[:, :, :, i].squeeze() - w_min) / (w_max - w_min)
    plt.imshow(wimg.astype('uint8'))
    plt.axis('off')
    plt.title(classes[i])
```

<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAxsAAAH/CAYAAAA/lMB0AAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjAsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvlHJYcgAAAAlwSFlzAAAPYQAAD2EBqD+naQAA3etJREFUeJzs3XeYZNdZJ/5v5dxdnXN3dZrunjyaoKxRtCTbEsJBZCSDkY1swLs2uwuskeQE2IABs15jYG1Ye2FtAzLGCpZspVEYaXLqmc45h+pUobuq7u8PVvPje88IWrKqR+H7eR4/1tt969YN5557z/T73uOwLMuCiIiIiIjI68x5sTdARERERETemjTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCgw0REREREckLDTZERERERCQvNNgAEIvFcPfdd1/szRAR2TD3338/HA4HZmZm/t3lXo/+8dprr8W11177Y61DRCRfXu4PJT802BAREZG3hLGxMdx///04duzYxd4UEfl/3Bd7A0RE5I3r3LlzcDr171Ly5jA2NoYHHngAsVgMO3fuvNibIyLQXzZE3vJSqRRyudzF3gx5k/L5fPB4PP/uMisrKxu0NSIibw1vp37zLT3YeDkH7+zZs7jzzjtRUFCAkpIS/MZv/AZSqdQrfm5ubg6f+MQnsG3bNoTDYRQUFODWW2/F8ePHabknn3wSDocD3/rWt/DZz34WtbW18Pv9uOGGG9DT02Os9+DBg7jllltQWFiIYDCI/fv349lnn33d91venEZHR/HLv/zLqK6uhs/nQ2NjI371V38Vq6urr7pN/v3f/z3++3//76ipqUEwGMTi4uJF2it5o5uZmfl3+0d7zcbXv/51OBwOPPXUU7j33ntRXl6O2tra87//6le/iubmZgQCAezbtw/PPPPMRu6OvIn9uH3gk08+ib179wIAPvCBD8DhcMDhcODrX//6RdojeSM6cOAA9u7dC7/fj+bmZvzFX/zFBZf7xje+gd27dyMQCKC4uBg//dM/jeHhYWO59Tzbvfw8eubMGfzsz/4sioqKcNVVV+Vl/96I3hZpVHfeeSdisRh+7/d+Dy+88AL+7M/+DPPz8/jbv/3bCy7f19eHBx98EO9///vR2NiIyclJ/MVf/AX279+PM2fO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uE/siPPxe6zZrDVp7+ean6Cb+69sG/dftRPcHj0vcL0PAKy8i2svF8/yPTbdz9tl1XB91JXTfJ09t9W8z08d4j4hmuV+MrKJ7/OunG2/LtCHLAzyfbl40azb2gjLtueckXbejpak+WzgL+M63FNhvqZDFp/n5QQfr4W+GMU1QfMZcMbJ/Vulrbbk+Vl+dthte3ZNPGvWbBzYzW0ymeZ+ZdcTfJ7ihdyXdQ6YfepAG9eOXD3KzwbZYt5Oa4XvnyUFXE81dYBrTAGg3sU1o8u7uD+L2moAA328nUs95jls2cwzGqY9Zj3UeugvGyIiIiIikhcabIiIiIiISF5osCEiIiIiInnhsCzL+o8XExEREREReXX0lw0REREREckLDTZERERERCQvNNgQEREREZG80GBDRERERETyQoMNERERERHJCw02REREREQkLzTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCgw0REREREckLDTZERERERCQvNNgQEREREZG80GBDRERERETyQoMNERERERHJCw02REREREQkLzTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCgw0REREREckLDTZERERERCQvNNgQEREREZG80GBDRERERETyQoMNERERERHJCw02REREREQkLzTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCgw0REREREckLDTZERERERCQvNNgQEREREZG80GBDRERERETyQoMNERERERHJCw02REREREQkLzTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCgw0REREREckLDTZERERERCQvNNgQEREREZG80GBDRERERETyQoMNERERERHJCw02REREREQkLzTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCgw0REREREckLDTZERERERCQvNNgQEREREZG80GBDRERERETyQoMNERERERHJCw02REREREQkLzTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCgw0REREREckLDTZERERERCQvNNgQEREREZG80GBDRERERETyQoMNERERERHJCw02REREREQkLzTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCgw0REREREckLDTZERERERCQvNNgQEREREZG80GBDRERERETyQoMNERERERHJCw02REREREQkLzTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCgw0REREREckLDTZERERERCQvNNgQEREREZG80GBDRERERETyQoMNERERERHJCw02REREREQkLzTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCgw0REREREckLDTZERERERCQvNNgQEREREZG80GBDRERERETyQoMNERERERHJCw02REREREQkLzTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCgw0REREREckLDTZERERERCQvNNgQEREREZG80GBDRERERETyQoMNERERERHJCw02REREREQkLzTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCgw0REREREckLDTZERERERCQvNNgQEREREZG80GBDRERERETyQoMNERERERHJCw02REREREQkLzTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCgw0REREREckLDTZERERERCQvNNgQEREREZG80GBDRERERETyQoMNERERERHJCw02REREREQkLzTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCgw0REREREckLDTZERERERCQvNNgQEREREZG80GBDRERERETyQoMNERERERHJCw02REREREQkLzTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCgw0REREREckLDTZERERERCQvNNgQEREREZG80GBDRERERETyQoMNERERERHJCw02REREREQkLzTYEBERERGRvNBgQ0RERERE8kKDDRERERERyQsNNkREREREJC802BARERERkbzQYENERERERPJCg40LuP/+++FwOC72Zshb3EsvvYQrrrgCoVAIDocDx44du9ibJG8xL/dlMzMzF3tTRF6Va6+9Flu3bv0PlxsYGIDD4cDXv/71/G+UyGugfhhwX+wNEHk7Wltbw/vf/374/X588YtfRDAYRENDw8XeLBERkbeU5557Dj/4wQ/wsY99DNFo9GJvztuSBhsiF0Fvby8GBwfxl3/5l/jgBz94sTdHRORNqaGhAclkEh6P52JvirxBPffcc3jggQdw9913a7BxkSiNSuQimJqaAoD/sONbWVnZgK0ReW0sy0IymbzYmyFvYw6HA36/Hy6X62JvirzJ5XI5pFKpi70Zb0lv+8HGgQMHsHfvXvj9fjQ3N+Mv/uIvjGUymQw+/elPo7m5GT6fD7FYDL/927+NdDpNy+VyOdx///2orq5GMBjEddddhzNnziAWi+Huu+/eoD2SN7q7774b+/fvBwC8//3vh8PhwLXXXou7774b4XAYvb29eOc734lIJIKf+7mfA/Cvg46Pf/zjqKurg8/nQ1tbG/7wD/8QlmXRupPJJH79138dpaWliEQiuP322zE6OgqHw4H7779/o3dV3iDi8fj5f9UrLCzEBz7wASQSifO/X28fF4vF8O53vxuPPvoo9uzZg0AgcL7PfOyxx3DVVVchGo0iHA6jra0Nv/3bv02fT6fTuO+++9DS0gKfz4e6ujr8l//yX4zvkbe+paUlfOxjH0MsFoPP50N5eTluuukmHDlyhJY7c+YMrrvuOgSDQdTU1ODzn/88/f5CNRsv96V9fX24+eabEQqFUF1djU996lNGnylvbffffz9+8zd/EwDQ2NgIh8MBh8Nxvt189KMfxTe/+U1s2bIFPp8PjzzyCJ588kk4HA48+eSTtK5Xqg86e/Ys7rzzTpSVlSEQCKCtrQ2/8zu/8+9u1+DgIFpaWrB161ZMTk6+nrv8hvS2TqM6efIk3vGOd6CsrAz3338/MpkM7rvvPlRUVNByH/zgB/E3f/M3eN/7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" alt="img" style="zoom:50%;" />







## 3.Implement a Softmax classifier（实现一个 Softmax 分类器）



### A.理论部分：

Softmax分类器的公式如下：

<img src="https://gitee.com/Slexy/picture/raw/master/20250324155607124.png" alt="image-20250324155607007" style="zoom:50%;" />

他代表的是每一个正确的分类占全部分类的分数的一个概率，他得到的是一个在 0 到 1 区间内的一个分数，而不是svm的一个分数（个人认为这个分数看不出什么）

### B.代码部分：

#### 1.数据的预处理

同上

#### 2.构建Softmax Classifier

（1）计算loss和dW

```python
def softmax_loss_vectorized(W, X, y, reg):
    """
    Softmax loss function, vectorized version.

    Inputs and outputs are the same as softmax_loss_naive.
    """
    # Initialize the loss and gradient to zero.
    loss = 0.0
    dW = np.zeros_like(W)

    num_classes = W.shape[1]
    num_train = X.shape[0]

    # 计算分数
    scores = np.dot(X, W)
    
    # 为了数值稳定，减去每个样本的最大分数
    scores -= np.max(scores, axis=1, keepdims=True)

    # 计算 softmax 概率
    exp_scores = np.exp(scores)
    sum_exp_scores = np.sum(exp_scores, axis=1, keepdims=True)
    possibility = exp_scores / sum_exp_scores

    # 创建 one-hot 编码的掩码
    temper = np.zeros_like(possibility)
    temper[np.arange(num_train), y] = 1

    # 计算损失
    correct_logprobs = np.log(possibility[np.arange(num_train), y])
    loss = -np.sum(correct_logprobs)

    # 计算梯度
    dW = np.dot(X.T, (possibility - temper))

    # 平均损失和梯度
    loss /= num_train
    dW /= num_train

    # 加上正则化损失和梯度
    loss += reg * np.sum(W * W)
    dW += 2 * reg * W

    return loss, dW
```



其中有几点比较重要：

- 首先是 `scores -= np.max(scores, axis=1, keepdims=True)` 需要减去每一行的最大值，控制数值的稳定

- dW的计算公式：

  <img src="https://gitee.com/Slexy/picture/raw/master/20250324160921030.png" alt="image-20250324160920709" style="zoom:50%;" />

  故可以计算dW和loss并返回，用于后续的训练过程中



**后续过程大概同2.**



## 4.Two-Layer Neural Network（双层神经网络）

### A.理论部分

在这一节里面，主要是介绍了如何构建前向传播和反向传播的全连接网络函数，首先给出了两个示例：

#### （1）前向传播

<img src="https://gitee.com/Slexy/picture/raw/master/20250324161514778.png" alt="image-20250324161514700" style="zoom:50%;" />

接受对应层所需要的参数用`cache`储存这些参数，并且计算结果，返回结果和`cache`，这层的形式有很多，比如说线性变换，relu，softmax等

#### （2）反向传播

<img src="https://gitee.com/Slexy/picture/raw/master/20250324161531910.png" alt="image-20250324161531709" style="zoom:50%;" />

接受前一层传来的梯度 `dout` 和储存的 `cache` 计算出该层参数对应的梯度，`dw`和`dx` （`db`，如果有的话）,然后返回dx和dw进入到上一层中

### B.代码部分

##### （1）仿射变化前向传播

```python
def affine_forward(x, w, b):
    """
    Inputs:
    - x: A numpy array containing input data, of shape (N, d_1, ..., d_k)
    - w: A numpy array of weights, of shape (D, M)
    - b: A numpy array of biases, of shape (M,)

    Returns a tuple of:
    - out: output, of shape (N, M)
    - cache: (x, w, b)
    """
    out = None
    cache = (x, w, b)
    
    x1 = np.reshape(x,(x.shape[0],-1))
    out = np.dot(x1,w) + b
   
    return out, cache
```

##### （2）仿射变化反向传播

```python
def affine_backward(dout, cache):
    """
    Inputs:
    - dout: Upstream derivative, of shape (N, M)
    - cache: Tuple of:
      - x: Input data, of shape (N, d_1, ... d_k)
      - w: Weights, of shape (D, M)
      - b: Biases, of shape (M,)

    Returns a tuple of:
    - dx: Gradient with respect to x, of shape (N, d1, ..., d_k)
    - dw: Gradient with respect to w, of shape (D, M)
    - db: Gradient with respect to b, of shape (M,)
    """
    x, w, b = cache
    dx, dw, db = None, None, None

    dx = np.dot(dout,w.T)
    dx = np.reshape(dx,x.shape)

    x1 = np.reshape(x,(x.shape[0],-1))

    dw = np.dot(x1.T,dout)

    db = np.sum(dout,axis=0)

    return dx, dw, db
```

##### （3）relu前向传播

```python
def relu_forward(x):
    """
    Input:
    - x: Inputs, of any shape

    Returns a tuple of:
    - out: Output, of the same shape as x
    - cache: x
    """
    out = None
    cache = x
    
    out = np.maximum(x,0)

    return out, cache
```

##### （4）relu前向传播

```python
def relu_backward(dout, cache):
    """
    Computes the backward pass for a layer of rectified linear units (ReLUs).

    Input:
    - dout: Upstream derivatives, of any shape
    - cache: Input x, of same shape as dout

    Returns:
    - dx: Gradient with respect to x
    """
    dx, x = None, cache

    dx = dout * (x > 0)
    
    return dx
```





关于具体模型的构建示例会在assignment2的任务1中提到，这里的model建立不完整就先不提及。

##### （5）建立solve的主函数

完成构建后可以实现如下的效果，传入参数进行训练

<img src="https://gitee.com/Slexy/picture/raw/master/20250324163432000.png" alt="image-20250324163431863" style="zoom:50%;" />

```python
class Solver(object):
    def __init__(self, model, data, **kwargs):
        """
        创建一个新的solver实例
        """

    def _reset(self):
        """
        为优化器设定一些变量
        """
        
    def _step(self):
        """
        做单次的梯度更新
        """

    def _save_checkpoint(self):
        

    def check_accuracy(self, X, y, num_samples=None, batch_size=100):
        """
        检查这个模型关于测试集的正确率
        """

    def train(self):
        """
        运行优化器来训练这个模型
        """
```

### C.调整超参数部分

**设定一个lr和rg区间用于进行小批量的训练，测试出较好的超参数性能后再转到大的训练集上进行训练**

```py
for lr in learning_rates:
    for reg in regularization_strengths:
        for hidden_size in hidden_sizes:
            # 创建模型
            model = TwoLayerNet(input_dim=3*32*32, hidden_dim=hidden_size, num_classes=10, weight_scale=1e-3, reg=reg)

            # 创建Solver实例
            solver = Solver(model, data,
                            update_rule='sgd',
                            optim_config={
                                'learning_rate': lr,
                            },
                            lr_decay=0.95,
                            num_epochs=5, batch_size=200,
                            print_every=100)

            # 训练模型
            solver.train()

            # 获取验证集准确率
            val_acc = solver.val_acc_history[-1]

            # 更新最佳模型
            if val_acc > best_val_acc:
                best_val_acc = val_acc
                best_model = model

            print('lr %e, reg %e, hidden_size %d, val_acc: %f' % (lr, reg, hidden_size, val_acc))

print('Best validation accuracy: %f' % best_val_acc)
```

## 5.Higher Level Representations: Image Features（用图像特征替代图像原始像素进行输入）

### A.理论部分

附上链接，等





# assignment2

## 1.Multi-Layer Fully Connected Neural Networks（多层全连接神经网络）

### B.代码部分

前向传播和反向传播的代码可以同上，本节没有附加多的

### （1）构建多层全连接神经网络的模型

##### 1.模型的_init_

```python
class FullyConnectedNet(object):

    def __init__(
        self,
        hidden_dims,
        input_dim=3 * 32 * 32,
        num_classes=10,
        dropout_keep_ratio=1,
        normalization=None,
        reg=0.0,
        weight_scale=1e-2,
        dtype=np.float32,
        seed=None,
    ):
        """Initialize a new FullyConnectedNet.
        
        Inputs:
        - hidden_dims：一个整数列表，给出每个隐藏层的大小。
    	- input_dim：一个整数，给出输入的大小。
    	- num_classes：一个整数，给出要分类的类别数量。
    	- dropout_keep_ratio：介于0和1之间的标量，表示dropout的强度。
        如果dropout_keep_ratio=1，则网络根本不应使用dropout。
    	- normalization：网络应使用的归一化类型。有效值为"batchnorm"（批归一化）、"layernorm"（层归		一化），或者None表示不使用归一化（默认值）。
    	- reg：给出L2正则化强度的标量。
    	- weight_scale：给出权重随机初始化标准差的标量。
    	- dtype：一个numpy数据类型对象；所有计算都将使用此数据类型进行。
        float32速度更快但精度较低，因此在进行数值梯度检查时，你应该使用float64。
    	- seed：如果不为None，则将此随机种子传递给dropout层。
        这将使dropout层确定性化，以便我们可以对模型进行梯度检查。
    	"""
        self.normalization = normalization
        self.use_dropout = dropout_keep_ratio != 1
        self.reg = reg
        self.num_layers = 1 + len(hidden_dims)
        self.dtype = dtype
        self.params = {}

        # 预处理每个层的参数
        layer_dims = [input_dim] + hidden_dims + [num_classes]
        
        # 这个部分在为每一层设定初始的W和b #
        #############################################################
        for i in range(self.num_layers):
            # Initialize weights and biases for layer i+1
            self.params[f'W{i+1}'] = weight_scale * np.random.randn(layer_dims[i], layer_dims[i+1])
            self.params[f'b{i+1}'] = np.zeros(layer_dims[i+1])
            
            # Initialize gamma and beta for batch normalization if needed
            if self.normalization in ['batchnorm', 'layernorm'] and i < len(hidden_dims):
                self.params[f'gamma{i+1}'] = np.ones(layer_dims[i+1])
                self.params[f'beta{i+1}'] = np.zeros(layer_dims[i+1])

		#############################################################

        self.dropout_param = {}
        if self.use_dropout:
            self.dropout_param = {"mode": "train", "p": dropout_keep_ratio}
            if seed is not None:
                self.dropout_param["seed"] = seed

        self.bn_params = []
        if self.normalization == "batchnorm":
            self.bn_params = [{"mode": "train"} for i in range(self.num_layers - 1)]
        if self.normalization == "layernorm":
            self.bn_params = [{} for i in range(self.num_layers - 1)]

        # 将所有的参数转换为设定的的数据类型
        for k, v in self.params.items():
            self.params[k] = v.astype(dtype)
```

##### 2.计算loss部分

```python
def loss(self, X, y=None):
        """为全连接神经网络计算loss和gradients
        
        input：
    	- X: 输入数据数组，形状为 (N, d_1, ..., d_k)
        - y: 标签数组，形状为 (N,)。y[i] 给出 X[i] 的标签。

        return：
        如果 y 为 None，则运行模型的测试时前向传播并返回：
        - scores: 形状为 (N, C) 的数组，给出分类分数，其中
        scores[i, c] 是 X[i] 属于类别 c 的分类分数。

        如果 y 不为 None，则运行模型的训练时前向和后向传播并
        返回一个元组：
        - loss: 给出损失的标量值
        - grads: 与 self.params 键相同的字典，将参数
            名称映射到损失相对于这些参数的梯度。
        """
        X = X.astype(self.dtype)
        mode = "test" if y is None else "train"

        # Set train/test mode for batchnorm params and dropout param since they
        # behave differently during training and testing.
        if self.use_dropout:
            self.dropout_param["mode"] = mode
        if self.normalization == "batchnorm":
            for bn_param in self.bn_params:
                bn_param["mode"] = mode
        scores = None

        # 提前
        caches = {}
        out = X

        # 前向传播通过仿射变换层
        for i in range(self.num_layers - 1):
            W = self.params[f'W{i+1}']
            b = self.params[f'b{i+1}']

            # Affine layer
            out, caches[f'affine{i+1}'] = affine_forward(out, W, b)

            # 层归一化
            if self.normalization == 'batchnorm':
                gamma = self.params[f'gamma{i+1}']
                beta = self.params[f'beta{i+1}']
                out, caches[f'bn{i+1}'] = batchnorm_forward(out, gamma, beta, self.bn_params[i])
            elif self.normalization == 'layernorm':
                gamma = self.params[f'gamma{i+1}']
                beta = self.params[f'beta{i+1}']
                out, caches[f'ln{i+1}'] = layernorm_forward(out, gamma, beta, self.bn_params[i])

            # 使用relu作为激活函数
            out, caches[f'relu{i+1}'] = relu_forward(out)

            # dropout操作（如果有的话）
            if self.use_dropout:
                out, caches[f'dropout{i+1}'] = dropout_forward(out, self.dropout_param)

        # Forward pass for the last layer (affine)
        W = self.params[f'W{self.num_layers}']
        b = self.params[f'b{self.num_layers}']
        scores, caches[f'affine{self.num_layers}'] = affine_forward(out, W, b)


        # If test mode return early.
        if mode == "test":
            return scores

        loss, grads = 0.0, {}

        
        loss, dscores = softmax_loss(scores, y)

        # Add L2 regularization to the loss
        for i in range(1, self.num_layers + 1):
            W = self.params[f'W{i}']
            loss += 0.5 * self.reg * np.sum(W * W)

        # Backward pass for the last layer (affine)
        dout, dW, db = affine_backward(dscores, caches[f'affine{self.num_layers}'])
        grads[f'W{self.num_layers}'] = dW + self.reg * self.params[f'W{self.num_layers}']
        grads[f'b{self.num_layers}'] = db

        # Backward pass through hidden layers
        for i in range(self.num_layers - 1, 0, -1):
            # Dropout (optional)
            if self.use_dropout:
                dout = dropout_backward(dout, caches[f'dropout{i}'])

            # ReLU activation
            dout = relu_backward(dout, caches[f'relu{i}'])

            # Batch/Layer normalization (optional)
            if self.normalization == 'batchnorm':
                dout, dgamma, dbeta = batchnorm_backward(dout, caches[f'bn{i}'])
                grads[f'gamma{i}'] = dgamma
                grads[f'beta{i}'] = dbeta
            elif self.normalization == 'layernorm':
                dout, dgamma, dbeta = layernorm_backward(dout, caches[f'ln{i}'])
                grads[f'gamma{i}'] = dgamma
                grads[f'beta{i}'] = dbeta

            # Affine layer
            dout, dW, db = affine_backward(dout, caches[f'affine{i}'])
            grads[f'W{i}'] = dW + self.reg * self.params[f'W{i}']
            grads[f'b{i}'] = db
        pass


        return loss, grads
```

### （2）新的优化器实现：

##### 1.传统的SGD：（**Stochastic Gradient Descent**）

```python
def sgd(w, dw, config=None):
    """
    Performs vanilla stochastic gradient descent.

    config format:
    - learning_rate: 学习率
    """
    if config is None:
        config = {}
    config.setdefault("learning_rate", 1e-2)

    w -= config["learning_rate"] * dw
    return w, config

```

这个理论就不解释了



##### 2.动量**Momentum**：

```python
def sgd_momentum(w, dw, config=None):
    """
    Performs stochastic gradient descent with momentum.

    config format:
    - learning_rate: 标量学习率。
    - momentum: 介于 0 和 1 之间的标量，表示动量值。
      设置 momentum = 0 时，退化为普通随机梯度下降（sgd）。
    - velocity: 一个与 w 和 dw 形状相同的 numpy 数组，用于存储梯度的移动平均值。
    """
    
    if config is None:
        config = {}
    config.setdefault("learning_rate", 1e-2)
    config.setdefault("momentum", 0.9)
    v = config.get("velocity", np.zeros_like(w))
	"""
	如果传入的 config 为 None，则初始化一个空字典。
    使用 setdefault 方法为配置字典中的参数设置默认值：
    learning_rate：学习率，默认值为 1e-2（即 0.01）。
    momentum：动量值，默认值为 0.9。
    从配置字典中获取 velocity（速度）参数，如果不存在，则初始化为与 w 形状相同的零数组。
    """
    next_w = None
 
    v = config["momentum"] * v - config["learning_rate"] * dw # 更新速度
    
    next_w = w + v # 更新权重


    config["velocity"] = v

    return next_w, config
```

<img src="https://gitee.com/Slexy/picture/raw/master/20250326131224162.png" alt="image-20250326131224082" style="zoom: 67%;" />

##### 3.**RMSprop**

```python
def rmsprop(w, dw, config=None):
    """
    Uses the RMSProp update rule, which uses a moving average of squared
    gradient values to set adaptive per-parameter learning rates.

    config 格式：
    - learning_rate: 标量学习率。
    - decay_rate: 介于 0 和 1 之间的标量，表示梯度平方缓存的衰减率。
    - epsilon: 用于平滑处理的小标量，避免除以零。
    - cache: 梯度平方的移动平均。
    """
    
    if config is None:
        config = {}
    config.setdefault("learning_rate", 1e-2)
    config.setdefault("decay_rate", 0.99)
    config.setdefault("epsilon", 1e-8)
    config.setdefault("cache", np.zeros_like(w))

    next_w = None

    # RMSProp更新公式

    # 1. 更新cache：cache = decay * cache + (1 - decay) * (dw)^2
    config["cache"] = config["decay_rate"] * config["cache"] + (1 - config["decay_rate"]) * (dw ** 2)
    
    # 2. 更新权重：w = w - learning_rate * dw / (sqrt(cache) + epsilon)
    update = config["learning_rate"] * dw / (np.sqrt(config["cache"]) + config["epsilon"])
    next_w = w - update

    # 更新config中的cache
    config["cache"] = config["cache"]

    return next_w, config

```



<img src="https://gitee.com/Slexy/picture/raw/master/20250326131521013.png" alt="image-20250326131520899" style="zoom:67%;" />



<img src="https://gitee.com/Slexy/picture/raw/master/20250326131536310.png" alt="image-20250326131536170" style="zoom:67%;" />



##### 4.adam

```python
def adam(w, dw, config=None):
    """
    config 格式：
    - learning_rate: 标量学习率。
    - beta1: 一阶矩估计的衰减率。
    - beta2: 二阶矩估计的衰减率。
    - epsilon: 用于平滑处理的小标量，避免除以零。
    - m: 梯度的移动平均。
    - v: 梯度平方的移动平均。
    - t: 迭代次数。
    """
    
    if config is None:
        config = {}
    config.setdefault("learning_rate", 1e-3)
    config.setdefault("beta1", 0.9)
    config.setdefault("beta2", 0.999)
    config.setdefault("epsilon", 1e-8)
    config.setdefault("m", np.zeros_like(w))
    config.setdefault("v", np.zeros_like(w))
    config.setdefault("t", 0)

    next_w = None


    # 提取配置参数
    lr = config["learning_rate"]
    beta1 = config["beta1"]
    beta2 = config["beta2"]
    epsilon = config["epsilon"]
    m = config["m"]
    v = config["v"]
    t = config["t"]

    # 更新时间步
    t += 1

    # 更新一阶矩和二阶矩估计
    m = beta1 * m + (1 - beta1) * dw
    v = beta2 * v + (1 - beta2) * (dw ** 2)

    # 偏差校正
    m_hat = m / (1 - beta1 ** t)
    v_hat = v / (1 - beta2 ** t)

    # 计算更新步长
    update = lr * m_hat / (np.sqrt(v_hat) + epsilon)

    # 更新权重
    next_w = w - update

    # 更新配置中的参数
    config["m"] = m
    config["v"] = v
    config["t"] = t

    return next_w, config
```

<img src="https://gitee.com/Slexy/picture/raw/master/20250326132301702.png" alt="image-20250326132301341" style="zoom:67%;" />





<img src="https://gitee.com/Slexy/picture/raw/master/20250326132436157.png" alt="image-20250326132435760" style="zoom:67%;" />

##### 5.展示不同的优化器对于模型的性能和训练影响

<img src="https://gitee.com/Slexy/picture/raw/master/20250326133257837.png" alt="image-20250326133257326" style="zoom:67%;" />

​	可以非常显著的发现，当使用adam和rmsprop的时候，loss下降的速度远远的比sgd和sgd_momentum更好，说明他们可以更快的降低loss，起到加快训练的效果



<img src="https://gitee.com/Slexy/picture/raw/master/20250326133420136.png" alt="image-20250326133419644" style="zoom:67%;" />

<img src="https://gitee.com/Slexy/picture/raw/master/20250326133449790.png" alt="image-20250326133449339" style="zoom:67%;" />

​	而在训练集和验证集上的正确率也可以非常显著的反映这一点，当epoch = 8 左右，adam和rmsprop已经达到了57%+和37%+的正确率而sgd和sgd_momentum却还在缓慢的上升正确率，，说明adam和rmsprop在模型的训练过程中有非常好的效果，因此在之后我们一般都选用adam作为主要的优化器，来处理模型



## 2.Batch Normalization（批量归一化）

### A.理论部分：

​	机器学习方法在输入数据具有不相关特征且均值为零、方差为一时表现更好。在训练神经网络时，我们可以在将数据输入网络之前对其进行预处理，以明确去相关化其特征。这将确保网络的第一层看到的数据符合良好的分布。然而，即使我们预处理了输入数据，网络深层的激活值可能不再去相关化，也不再具有零均值或单位方差，因为它们是早期层的输出。更糟糕的是，在训练过程中，网络每一层的特征分布会随着每一层权重的更新而变化。

​	 论文的作者假设，深度神经网络内部特征分布的变化可能会使训练深度网络更加困难。为了解决这个问题，他们提出在网络中插入批标准化层。在训练时，这样的层使用一批数据来估计每个特征的均值和标准差。然后使用这些估计的均值和标准差来对这批数据的特征进行中心化和标准化。在训练过程中会保持这些均值和标准差的移动平均值，在测试时使用这些移动平均值来对特征进行中心化和标准化。

​	这种标准化策略可能会降低网络的表示能力，因为它可能有时对某些层来说，拥有非零均值或非单位方差的特征更优。为此，批标准化层为每个特征维度引入了可学习的平移和缩放参数。

### B.代码部分



### （1）构建优化器的结构：

##### 1.Batch Normalization: Forward Pass（前向传播）

```python
def batchnorm_forward(x, gamma, beta, bn_param):
    """前向传播过程用于批量归一化。

    在训练阶段，样本均值和（未校正的）样本方差会依据小批量统计信息计算得出，
    并用于对输入数据进行归一化处理。在训练期间，我们还会持续维护每个特征的均值和方差的指数衰减运行平均值，
    这些平均值会在测试阶段用于归一化数据。

    在每个时间步，我们会根据动量参数采用指数衰减的方式更新均值和方差的运行平均值：

    running_mean = momentum * running_mean + (1 - momentum) * sample_mean
    running_var = momentum * running_var + (1 - momentum) * sample_var

    注意，批量归一化论文提出了一种不同的测试阶段行为：
    他们会使用大量训练图像为每个特征计算样本均值和方差，而非采用运行平均值。
    在此实现中，我们选择使用运行平均值，因为这样无需额外的估计步骤；
    torch7 实现的批量归一化也采用了运行平均值。

    输入:
    - x: 形状为 (N, D) 的数据
    - gamma: 形状为 (D,) 的缩放参数
    - beta: 形状为 (D,) 的偏移参数
    - bn_param: 包含以下键的字典:
      - mode: 'train' 或 'test'; 必需
      - eps: 用于数值稳定性的常数
      - momentum: 用于运行均值 / 方差的常数
      - running_mean: 形状为 (D,) 的数组，表示特征的运行均值
      - running_var: 形状为 (D,) 的数组，表示特征的运行方差

    返回一个元组:
    - out: 形状为 (N, D)
    - cache: 反向传播所需的值的元组
    """
    # 获取模式（训练或测试）
    mode = bn_param["mode"]
    # 获取用于数值稳定性的常数，默认为 1e-5
    eps = bn_param.get("eps", 1e-5)
    # 获取动量参数，默认为 0.9
    momentum = bn_param.get("momentum", 0.9)

    # 获取输入数据的形状
    N, D = x.shape
    # 获取特征的运行均值，若未提供则初始化为零向量
    running_mean = bn_param.get("running_mean", np.zeros(D, dtype=x.dtype))
    # 获取特征的运行方差，若未提供则初始化为零向量
    running_var = bn_param.get("running_var", np.zeros(D, dtype=x.dtype))

    # 初始化输出和缓存
    out, cache = None, None
    if mode == "train":
        # 计算小批量均值
        sample_mean = np.mean(x, axis=0)
        # 计算小批量方差
        sample_var = np.var(x, axis=0)
        # 归一化数据
        normalized_x = (x - sample_mean) / np.sqrt(sample_var + eps)
        # 缩放和偏移
        out = gamma * normalized_x + beta
        # 更新运行均值和方差
        running_mean = momentum * running_mean + (1 - momentum) * sample_mean
        running_var = momentum * running_var + (1 - momentum) * sample_var
        # 缓存值，用于反向传播
        cache = (x, gamma, sample_mean, sample_var, eps, normalized_x)
    elif mode == "test":
        # 使用运行均值和方差归一化数据
        normalized_x = (x - running_mean) / np.sqrt(running_var + eps)
        # 缩放和偏移
        out = gamma * normalized_x + beta
        # 测试模式不需要缓存
        cache = None
    else:
        raise ValueError('Invalid forward batchnorm mode "%s"' % mode)

    # 将更新后的运行均值和方差存储回 bn_param
    bn_param["running_mean"] = running_mean
    bn_param["running_var"] = running_var

    return out, cache
```



1. **计算小批量均值**  
   针对输入数据 x_i 的每一个特征维度，计算小批量数据的均值：  
   $$
   \mu = \frac{1}{N} \sum_{i=1}^{N} x_i
   $$
   其中 N 代表小批量数据的样本数量，x_i 表示第 i 个样本。

2. **计算小批量方差**  
   针对输入数据 x 的每一个特征维度，计算小批量数据的方差：  
   $$
   \sigma^2 = \frac{1}{N} \sum_{i=1}^{N} (x_i - \mu)^2
   $$

3. **归一化数据**  
   借助计算得到的均值和方差对输入数据进行归一化处理：  
   $$
   \hat{x}_i = \frac{x_i - \mu}{\sqrt{\sigma^2 + \epsilon}}
   $$
   其中 epsilon 是一个极小的常数，其作用是保证数值的稳定性。

4. **缩放和偏移**  
   对归一化后的数据进行缩放和偏移操作：  
   $$
   y_i = \gamma \hat{x}_i + \beta
   $$
   这里的 gamma 是缩放参数，beta 是偏移参数。

5. **更新运行均值和方差**  
   在训练过程中，持续更新运行均值和方差以供测试阶段使用：  
   $$
   \text{running\_mean} = \text{momentum} \times \text{running\_mean} + (1 - \text{momentum}) \times \text{sample\_mean}
   $$
   $$
   \text{running\_var} = \text{momentum} \times \text{running\_var} + (1 - \text{momentum}) \times \text{sample\_var}
   $$
   其中 momentum 是动量参数。



##### 2.Batch Normalization: Backward Pass（反向传播）

```python
def batchnorm_backward(dout, cache):
    """批量归一化的反向传播过程。

    对于此实现，你应该在纸上画出批量归一化的计算图，
    并通过中间节点反向传播梯度。

    输入:
    - dout: 上游导数，形状为 (N, D)
    - cache: 来自 batchnorm_forward 的中间变量。

    返回一个元组:
    - dx: 关于输入 x 的梯度，形状为 (N, D)
    - dgamma: 关于缩放参数 gamma 的梯度，形状为 (D,)
    - dbeta: 关于偏移参数 beta 的梯度，形状为 (D,)
    """
    dx, dgamma, dbeta = None, None, None

    # 从缓存中获取前向传播时保存的中间变量
    x = cache[0]
    gamma = cache[1]
    sample_mean = cache[2]
    sample_var = cache[3]
    eps = cache[4]
    normalized_x = cache[5]
    # 获取样本数量
    N = x.shape[0]

    # 计算关于 beta 的梯度，即 dout 沿着样本维度求和
    dbeta = np.sum(dout, axis=0)
    # 计算关于 gamma 的梯度，即 dout 乘以归一化后的 x 再沿着样本维度求和
    dgamma = np.sum(dout * normalized_x, axis=0)

    # 计算 1 除以标准差
    inv_std = 1.0 / np.sqrt(sample_var + eps)
    # 计算输入 x 减去均值
    x_minus_mean = x - sample_mean

    # 计算 dx 的三个部分

    # 第一部分：dout 乘以 gamma
    dy_hat = dout * gamma
    # 第二部分：计算关于方差的梯度
    dvar = np.sum(dy_hat * x_minus_mean, axis=0) * (-0.5) * inv_std**3
    # 第三部分：计算关于均值的梯度
    dmean = np.sum(dy_hat * (-inv_std), axis=0) + dvar * np.mean(-2.0 * x_minus_mean, axis=0)

    # 最终的 dx，由三部分组合而成
    dx = dy_hat * inv_std + dvar * 2.0 * x_minus_mean / N + dmean / N

    return dx, dgamma, dbeta

```

<img src="https://gitee.com/Slexy/picture/raw/master/20250326183714117.png" alt="image-20250326183713581" style="zoom:67%;" />

这个公式实际的核心就是上述的四个式子和下面的一个Loss和X之间的关系，下面是一份我自己根据公式求的偏导：

<img src="https://gitee.com/Slexy/picture/raw/master/20250326183814080.png" alt="image-20250326183813977" style="zoom: 50%;" />



根据这两个公式，就可以很好的推导出反向传播中关于x_i的梯度，应用于反向传播的实现中

##### 3.测试Batch Normalization对训练的影响

下面这张图是训练的loss曲线，他代表着有无使用Batch Normailzation对训练的影响

<img src="https://gitee.com/Slexy/picture/raw/master/20250410163419752.png" alt="image-20250410163419650" style="zoom:50%;" />

以及不同的初始权重设置和有无归一化两者结合对于训练的影响：

<img src="https://gitee.com/Slexy/picture/raw/master/20250410163552324.png" alt="image-20250410163552228" style="zoom:50%;" />



##### 4.层归一化 Layer Normalization

接下来介绍的是层归一化，下面摘录于cs231n：



- 批归一化：

  ​	*你可以把批归一化想象成给一群人排队体检。这里的 “一群人” 就是一个批次的数据，每个人身上有不同的 “特征指标”，比如身高、体重、血压等。批归一化就像是对每一项 “特征指标” 进行调整，让这群人在这个指标上的数值分布变得更规整。例如，把所有人的身高都调整到一个相对集中的范围，使得后续的 “检查流程”（模型训练）能更顺畅。不过，如果这 “一群人” 数量太少，那调整出来的结果可能就不太准。*

  ​	*批归一化是一种在深度学习中常用的归一化技术，主要用于对一个批次内的数据在特征维度上进行归一化处理。在训练过程中，对于每一个特征，它会计算该批次内所有样本在这个特征上的均值和方差，然后利用这些统计量将该特征的输入数据进行标准化，使其均值为 0，方差为 1。之后，通过引入可学习的缩放因子和偏移因子，对标准化后的数据进行线性变换，以恢复数据的表达能力。由于批归一化依赖于批次内的数据统计信息，所以它对批次大小比较敏感，当批次大小较小时，计算得到的均值和方差可能不稳定，从而影响模型的性能。在推理阶段，通常使用训练过程中通过移动平均法得到的全局均值和方差进行归一化。*



- 层归一化

  ​	*层归一化好比是给每个人单独制定一套健康标准。对于每一个人（单个样本），综合考虑他自身的各项 “特征指标”（如身高、体重、血压等），计算出适合这个人的均值和标准范围，然后在这个范围内对各项指标进行调整。不管来体检的人是多是少，每个人的调整都是独立进行的，不会受到其他人的影响。*

  

  ​	*层归一化同样是一种归一化方法，它与批归一化的主要区别在于归一化的维度。层归一化是在单个样本上，沿着除了批量维度之外的所有其他维度进行归一化。对于每个样本，它会计算该样本所有特征维度上的均值和方差，然后对这些特征进行标准化处理，使得每个样本的特征数据具有零均值和单位方差。与批归一化不同，层归一化不需要维护全局的统计信息，在训练和推理阶段的计算方式是一致的，不依赖于批次大小。这使得层归一化在处理序列长度可变的数据（如自然语言处理中的句子）或批次大小较小的情况时具有优势。*



下面展示的是层归一化的实现：

```python
def layernorm_forward(x, gamma, beta, ln_param):

    out, cache = None, None
    eps = ln_param.get("eps", 1e-5)

    sample_mean = np.mean(x, axis=0)
    # 计算小批量方差
    sample_var = np.var(x, axis=0)
    # 归一化数据
    normalized_x = (x - sample_mean) / np.sqrt(sample_var + eps)
    # 缩放和偏移
    out = gamma * normalized_x + beta
    # 缓存值，用于反向传播
    cache = (x, gamma, sample_mean, sample_var, eps, normalized_x)   
    pass


    return out, cache
```



## 3.Dropout （随机失活）

### B.代码部分：

#### （1）实现dropout

Dropout 是一种通过在正向传播过程中随机将一些输出激活设置为零来正则化神经网络的技术。

在神经网络训练过程中，模型可能会对训练数据过度学习，捕捉到数据中的噪声和特定模式，导致在测试数据上表现不佳，即出现过拟合现象。随机失活通过在训练时随机 “丢弃”（置为 0）一部分神经元，使得模型不能过度依赖某些特定的神经元，从而迫使网络学习到更具鲁棒性和泛化能力的特征表示。可以把它想象成一种 “集体智慧”，网络中的每个神经元都不能过度依赖其他特定神经元的输出，而是要学会在不同的神经元组合下都能做出合理的决策。

从另一个角度看，随机失活相当于在训练过程中构建了多个不同的子网络。每次训练时，随机选择不同的神经元子集进行工作，这些子网络可以看作是对原始网络的不同 “采样”。在预测阶段，将所有这些子网络的结果进行平均（通过缩放神经元的输出），相当于进行了一种模型集成，而模型集成通常能够提高模型的性能和稳定性。

**随机失活的实现过程：**

**训练：**

1. **设置丢弃概率**：定义一个丢弃概率 p，它表示每个神经元在每次训练迭代中被丢弃的概率。例如，当 \(p = 0.5\) 时，意味着每个神经元有 50% 的概率被丢弃。
2. **生成掩码**：对于每一次训练迭代，为每一层的神经元生成一个二进制掩码（Mask）。掩码中的每个元素对应一个神经元，取值为 0 或 1，其中 0 表示该神经元被丢弃，1 表示该神经元保留。掩码的生成是基于伯努利分布的，即每个元素以概率 p 取值为 0，以概率 \(1 - p\) 取值为 1。
3. **应用掩码**：将生成的掩码与该层神经元的输出相乘，从而将被丢弃的神经元的输出置为 0。
4. **缩放输出**：为了保证在测试阶段和训练阶段神经元的输出期望一致，需要对经过掩码处理后的输出进行缩放。缩放因子为 \(\frac{1}{1 - p}\)。

**测试**：

在测试阶段，不再进行随机丢弃操作，而是直接使用所有的神经元。为了与训练阶段的输出期望保持一致，需要将神经元的输出乘以 \(1 - p\)。



##### 1.前向传播

```python
def dropout_forward(x, dropout_param):
    """Forward pass for inverted dropout.

    Note that this is different from the vanilla version of dropout.
    Here, p is the probability of keeping a neuron output, as opposed to
    the probability of dropping a neuron output.
    See http://cs231n.github.io/neural-networks-2/#reg for more details.

    Inputs:
    - x: Input data, of any shape
    - dropout_param: A dictionary with the following keys:
      - p: Dropout parameter. We keep each neuron output with probability p.
      - mode: 'test' or 'train'. If the mode is train, then perform dropout;
        if the mode is test, then just return the input.
      - seed: Seed for the random number generator. Passing seed makes this
        function deterministic, which is needed for gradient checking but not
        in real networks.

    Outputs:
    - out: Array of the same shape as x.
    - cache: tuple (dropout_param, mask). In training mode, mask is the dropout
      mask that was used to multiply the input; in test mode, mask is None.
    """
    p, mode = dropout_param["p"], dropout_param["mode"]
    if "seed" in dropout_param:
        np.random.seed(dropout_param["seed"])

    mask = None
    out = None

    if mode == "train":
        mask = np.random.binomial(1, p, size=x.shape)
        out = x * mask / p
    elif mode == "test":
        out = x.copy()  # 或直接返回x，无需操作

    cache = (dropout_param, mask)
    out = out.astype(x.dtype, copy=False)

    return out, cache
```

##### 2.反向传播

```python
def dropout_backward(dout, cache):
    """Backward pass for inverted dropout.

    Inputs:
    - dout: Upstream derivatives, of any shape
    - cache: (dropout_param, mask) from dropout_forward.
    """
    dropout_param, mask = cache
    mode = dropout_param["mode"]
    p = dropout_param["p"]

    dx = None

    if mode == "train":
        dx = dout * mask * (1 / p)
    elif mode == "test":
        dx = dout
    return dx
```



##### 3.效果展示：

<img src="https://gitee.com/Slexy/picture/raw/master/20250410184428412.png" alt="image-20250410184428290" style="zoom: 80%;" />

​	这个分别是使用或者不使用dropout在训练的反应，可以比较明显的看出虽然使用了随机失活在训练集中训练正确率比较低，但是在验证集中随机失活的效果明显比不使用随机失活的时候更加好，说明了随机失活比较好的抑制了过拟合的产生，可以对模型的训练起到更好的性能



## 4.Convolutional Neural Networks（卷积神经网络）

在这一节中我们主要需要实现主要的几个卷积神经网络的原理，包括但不限于，卷积层，池化层等



### B.代码部分

#### （1）卷积层：

<img src="https://gitee.com/Slexy/picture/raw/master/20250410190153030.png" alt="image-20250410190152177" style="zoom:67%;" />

卷积层主要由 卷积核的大小 步长 零填充 这三个东西进行确定 主要就是 通过卷积核和原始数据进行点乘矩阵运算（一个个相乘相加），加上偏置后得到答案，也可以参考下面的一维示意图：

![image-20250410190429633](https://gitee.com/Slexy/picture/raw/master/20250410190430267.png)



同样的可以使用一个简单的边缘检测和灰度转换来表明这个卷积核可以对图像做出的一些变换：

<img src="https://gitee.com/Slexy/picture/raw/master/20250410190730070.png" alt="image-20250410190729848" style="zoom:50%;" />

##### 1.前向传播：

```python
def conv_forward_naive(x, w, b, conv_param):
    """A naive implementation of the forward pass for a convolutional layer.

    The input consists of N data points, each with C channels, height H and
    width W. We convolve each input with F different filters, where each filter
    spans all C channels and has height HH and width WW.

    Input:
    - x: Input data of shape (N, C, H, W)
    - w: Filter weights of shape (F, C, HH, WW)
    - b: Biases, of shape (F,)
    - conv_param: A dictionary with the following keys:
      - 'stride': The number of pixels between adjacent receptive fields in the
        horizontal and vertical directions.
      - 'pad': The number of pixels that will be used to zero-pad the input.

    During padding, 'pad' zeros should be placed symmetrically (i.e equally on both sides)
    along the height and width axes of the input. Be careful not to modfiy the original
    input x directly.

    Returns a tuple of:
    - out: Output data, of shape (N, F, H', W') where H' and W' are given by
      H' = 1 + (H + 2 * pad - HH) / stride
      W' = 1 + (W + 2 * pad - WW) / stride
    - cache: (x, w, b, conv_param)
    """
    out = None
    N, C, H, W = x.shape
    F, _, HH, WW = w.shape
    stride = conv_param['stride']
    pad = conv_param['pad']

    # 计算输出尺寸
    H_out = 1 + (H + 2 * pad - HH) // stride
    W_out = 1 + (W + 2 * pad - WW) // stride

    # 对输入数据进行填充
    x_padded = np.pad(x, ((0, 0), (0, 0), (pad, pad), (pad, pad)), mode='constant')

    # 初始化输出数组
    out = np.zeros((N, F, H_out, W_out))

    # 执行卷积操作
    for n in range(N):
        for f in range(F):
            for i in range(H_out):
                for j in range(W_out):
                    # 提取当前卷积区域
                    x_region = x_padded[n, :, i * stride:i * stride + HH, j * stride:j * stride + WW]
                    # 执行卷积操作
                    out[n, f, i, j] = np.sum(x_region * w[f]) + b[f]

    cache = (x, w, b, conv_param)
    return out, cache
```

##### 2.反向传播

```python
def conv_backward_naive(dout, cache):
    """A naive implementation of the backward pass for a convolutional layer.

    Inputs:
    - dout: Upstream derivatives.
    - cache: A tuple of (x, w, b, conv_param) as in conv_forward_naive

    Returns a tuple of:
    - dx: Gradient with respect to x
    - dw: Gradient with respect to w
    - db: Gradient with respect to b
    """
    dx, dw, db = None, None, None
    x, w, b, conv_param = cache
    N, C, H, W = x.shape
    F, _, HH, WW = w.shape
    _, _, H_out, W_out = dout.shape
    stride = conv_param['stride']
    pad = conv_param['pad']

    # 初始化梯度
    dx = np.zeros_like(x)
    dw = np.zeros_like(w)
    db = np.zeros_like(b)

    # 对输入进行填充
    x_padded = np.pad(x, ((0, 0), (0, 0), (pad, pad), (pad, pad)), mode='constant')
    dx_padded = np.pad(dx, ((0, 0), (0, 0), (pad, pad), (pad, pad)), mode='constant')

    # 计算 db
    for f in range(F):
        db[f] = np.sum(dout[:, f, :, :])

    # 计算 dw 和 dx
    for n in range(N):
        for f in range(F):
            for i in range(H_out):
                for j in range(W_out):
                    # 提取当前的 dout 值
                    dout_val = dout[n, f, i, j]
                    # 计算 dw
                    x_region = x_padded[n, :, i * stride:i * stride + HH, j * stride:j * stride + WW]
                    dw[f] += dout_val * x_region
                    # 计算 dx
                    dx_padded[n, :, i * stride:i * stride + HH, j * stride:j * stride + WW] += dout_val * w[f]

    # 去除填充部分得到 dx
    dx = dx_padded[:, :, pad:pad + H, pad:pad + W]

    return dx, dw, db
```



#### （2）最大池化（一般的操作都是最大池化）

可以简单的理解为把一个含有多个参数的数据通过滑动取值范围只取最大的部分，提取特征出来，减少后面的数据量，下面是可以比较简单的图解：

<img src="https://gitee.com/Slexy/picture/raw/master/20250410191017897.png" alt="image-20250410191017728" style="zoom:67%;" />

##### 1.前向传播

```python
def max_pool_forward_naive(x, pool_param):
    """A naive implementation of the forward pass for a max-pooling layer.

    Inputs:
    - x: Input data, of shape (N, C, H, W)
    - pool_param: dictionary with the following keys:
      - 'pool_height': The height of each pooling region
      - 'pool_width': The width of each pooling region
      - 'stride': The distance between adjacent pooling regions

    No padding is necessary here, eg you can assume:
      - (H - pool_height) % stride == 0
      - (W - pool_width) % stride == 0

    Returns a tuple of:
    - out: Output data, of shape (N, C, H', W') where H' and W' are given by
      H' = 1 + (H - pool_height) / stride
      W' = 1 + (W - pool_width) / stride
    - cache: (x, pool_param)
    """
    out = None
    # 步骤1：获取输入尺寸和池化参数
    N, C, H, W = x.shape
    pool_height = pool_param['pool_height']
    pool_width = pool_param['pool_width']
    stride = pool_param['stride']

    # 计算输出尺寸 H' 和 W'
    # 根据公式 H' = 1 + (H - pool_height) / stride
    H_out = (H - pool_height) // stride + 1
    W_out = (W - pool_width) // stride + 1

    # 初始化输出数组
    out = np.zeros((N, C, H_out, W_out))

    # 步骤2：遍历所有样本、通道和空间位置
    for n in range(N):                  # 遍历每个样本
        for c in range(C):             # 遍历每个通道
            for h in range(H_out):      # 遍历输出高度维度
                # 计算当前池化窗口在输入中的高度起始和结束位置
                h_start = h * stride
                h_end = h_start + pool_height
                for w in range(W_out): # 遍历输出宽度维度
                    # 计算当前池化窗口在输入中的宽度起始和结束位置
                    w_start = w * stride
                    w_end = w_start + pool_width

                    # 提取当前池化窗口对应的输入区域
                    window = x[n, c, h_start:h_end, w_start:w_end]
                    # 取最大值作为输出
                    out[n, c, h, w] = np.max(window)

    cache = (x, pool_param)
    return out, cache
```



##### 2.反向传播

```python
def max_pool_backward_naive(dout, cache):
    """A naive implementation of the backward pass for a max-pooling layer.

    Inputs:
    - dout: Upstream derivatives
    - cache: A tuple of (x, pool_param) as in the forward pass.

    Returns:
    - dx: Gradient with respect to x
    """
    dx = None
    x, pool_param = cache  # 从缓存中提取前向传播的输入和参数
    N, C, H, W = x.shape
    pool_height = pool_param['pool_height']
    pool_width = pool_param['pool_width']
    stride = pool_param['stride']
    
    # 计算输出尺寸（与前向传播一致）
    H_out = (H - pool_height) // stride + 1
    W_out = (W - pool_width) // stride + 1
    
    # 初始化梯度 dx，形状与输入 x 相同
    dx = np.zeros_like(x)
    
    # 遍历每个样本、通道和输出位置
    for n in range(N):
        for c in range(C):
            for h in range(H_out):
                for w in range(W_out):
                    # 定位当前池化窗口在输入中的位置
                    h_start = h * stride
                    h_end = h_start + pool_height
                    w_start = w * stride
                    w_end = w_start + pool_width
                    window = x[n, c, h_start:h_end, w_start:w_end]
                    
                    # 找到最大值的位置（二维坐标）
                    max_idx = np.unravel_index(
                        np.argmax(window, axis=None),  # 展平后的最大值索引
                        window.shape                   # 窗口的原始形状
                    )
                    
                    # 将梯度 dout[n,c,h,w] 传递到输入中最大值的位置
                    dx[n, c, h_start + max_idx[0], w_start + max_idx[1]] += dout[n, c, h, w]
    
    return dx
```



## 5.PyTorch on CIFAR-10（在cifar10上使用pytorch）

#### B.代码部分：

#### （一）构建的框架：

设置设备：

```python
# 设置设备
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
console.print(f"[bold cyan]使用设备:[/bold cyan] [yellow]{device}[/yellow]")
```

首先的是数据的读取框架

```python
# 数据预处理和增强
transform_train = torchvision.transforms.Compose([
    torchvision.transforms.RandomCrop(32, padding=4),  # 随机裁剪
    torchvision.transforms.RandomHorizontalFlip(),     # 随机水平翻转
    torchvision.transforms.ToTensor(),                 # 转换为Tensor
    torchvision.transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010)),  # 标准化
])

transform_test = torchvision.transforms.Compose([
    torchvision.transforms.ToTensor(),                 # 转换为Tensor
    torchvision.transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010)),  # 标准化
])

# 准备训练和测试数据集
train_data = torchvision.datasets.CIFAR10("./dataset", train=True, transform=transform_train, download=True)
test_data = torchvision.datasets.CIFAR10("./dataset", train=False, transform=transform_test, download=True)

# 加载DataLoader
train_dataloader = DataLoader(dataset=train_data, batch_size=128, shuffle=True, num_workers=0, pin_memory=True)
test_dataloader = DataLoader(dataset=test_data, batch_size=100, shuffle=False, num_workers=0, pin_memory=True)
```

模型的定义：

可以参照这个作为模型的定义模版

```python
class AlexNet(nn.Module):
    """
    AlexNet模型定义 - 为CIFAR-10优化的版本
    """
    def __init__(self):
        super(AlexNet, self).__init__()
        self.features = Sequential(
            nn.Conv2d(3, 64, kernel_size=5, stride=1, padding=2),      # 第1卷积层
            nn.ReLU(inplace=True),                                     # ReLU激活函数
            nn.MaxPool2d(kernel_size=3, stride=2),                     # 第1池化层
            nn.Conv2d(64, 192, kernel_size=5, stride=1, padding=2),    # 第2卷积层
            nn.ReLU(inplace=True),                                     # ReLU激活函数
            nn.MaxPool2d(kernel_size=3, stride=2),                     # 第2池化层
            nn.Conv2d(192, 384, kernel_size=3, stride=1, padding=1),   # 第3卷积层
            nn.ReLU(inplace=True),                                     # ReLU激活函数
            nn.Conv2d(384, 256, kernel_size=3, stride=1, padding=1),   # 第4卷积层
            nn.ReLU(inplace=True),                                     # ReLU激活函数
            nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1),   # 第5卷积层
            nn.ReLU(inplace=True),                                     # ReLU激活函数
            nn.MaxPool2d(kernel_size=3, stride=2)                      # 第3池化层
        )
        self.classifier = nn.Sequential(
            nn.Linear(in_features=3 * 3 * 256, out_features=2048),     # 第1全连接层
            nn.ReLU(inplace=True),                                     # ReLU激活函数
            nn.Dropout(0.5),                                           # Dropout正则化
            nn.Linear(in_features=2048, out_features=1024),            # 第2全连接层
            nn.ReLU(inplace=True),                                     # ReLU激活函数
            nn.Dropout(0.5),                                           # Dropout正则化
            nn.Linear(1024, 10)                                        # 输出层
        )
        
        # 添加模型元数据
        self.metadata = {
            "name": "AlexNet-CIFAR10",
            "description": "针对CIFAR-10数据集优化的AlexNet变体",
            "input_size": (3, 32, 32),
            "num_classes": 10,
            "date_created": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

    def forward(self, x):
        x = self.features(x)           # 提取特征
        x = torch.flatten(x, 1)        # 将3D特征图展平为1D向量
        x = self.classifier(x)         # 分类
        return x

```

优化器的定义：

```python
# 定义损失函数和优化器
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001, betas=(0.9, 0.999), weight_decay=5e-4)
scheduler = optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=200)
```

训练过程：

```python
def train(epoch):
    """
    训练一个epoch
    参数:
        epoch: 当前epoch索引
    """
    model.train()
    train_loss = 0
    correct = 0
    total = 0
    
    start_time = time.time()
    
    for batch_idx, (inputs, targets) in enumerate(train_dataloader):
        inputs, targets = inputs.to(device), targets.to(device)
        
        # 梯度清零
        optimizer.zero_grad()
        
        # 前向传播
        outputs = model(inputs)
        loss = criterion(outputs, targets)
        
        # 反向传播和优化
        loss.backward()
        optimizer.step()
        
        # 统计
        train_loss += loss.item()
        _, predicted = outputs.max(1)
        total += targets.size(0)
        correct += predicted.eq(targets).sum().item()
    
    acc = 100. * correct / total
    avg_loss = train_loss / len(train_dataloader)
    elapsed_time = time.time() - start_time
    
    # 记录到TensorBoard
    writer.add_scalar('训练/损失', avg_loss, epoch)
    writer.add_scalar('训练/准确率', acc, epoch)
    writer.add_scalar('训练/时间', elapsed_time, epoch)
    writer.add_scalar('训练/学习率', optimizer.param_groups[0]['lr'], epoch)
    
    
    return avg_loss, acc, elapsed_time
```

#### （二）构建的一个实例

```python
import torch.nn as nn
import torch.optim as optim
from torch.nn import Sequential
import torchvision
from torch.utils.data import DataLoader
import torch
import os
import time
from torch.utils.tensorboard import SummaryWriter
import numpy as np
import datetime

# Rich库用于美化控制台输出
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, TextColumn, BarColumn, TimeElapsedColumn, TimeRemainingColumn
from rich.panel import Panel
from rich.live import Live
from rich import box
from rich.layout import Layout
from rich.style import Style
from rich.text import Text

# 创建Console实例
console = Console()

# 设置设备
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
console.print(f"[bold cyan]使用设备:[/bold cyan] [yellow]{device}[/yellow]")

# 设置随机种子以确保结果可复现
torch.manual_seed(42)
if torch.cuda.is_available():
    torch.cuda.manual_seed(42)
    torch.backends.cudnn.deterministic = True  # 确保每次运行结果一致
    torch.backends.cudnn.benchmark = False     # 关闭性能优化，确保结果一致

# 数据预处理和增强
transform_train = torchvision.transforms.Compose([
    torchvision.transforms.RandomCrop(32, padding=4),  # 随机裁剪
    torchvision.transforms.RandomHorizontalFlip(),     # 随机水平翻转
    torchvision.transforms.ToTensor(),                 # 转换为Tensor
    torchvision.transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010)),  # 标准化
])

transform_test = torchvision.transforms.Compose([
    torchvision.transforms.ToTensor(),                 # 转换为Tensor
    torchvision.transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010)),  # 标准化
])

# 显示数据加载信息
with console.status("[bold green]正在加载CIFAR-10数据集...", spinner="dots"):
    # 准备训练和测试数据集
    train_data = torchvision.datasets.CIFAR10("./dataset", train=True, transform=transform_train, download=True)
    test_data = torchvision.datasets.CIFAR10("./dataset", train=False, transform=transform_test, download=True)

    # 加载DataLoader
    train_dataloader = DataLoader(dataset=train_data, batch_size=128, shuffle=True, num_workers=0, pin_memory=True)
    test_dataloader = DataLoader(dataset=test_data, batch_size=100, shuffle=False, num_workers=0, pin_memory=True)

# 创建布局组件
layout = Layout()
layout.split_column(
    Layout(name="header", size=3),
    Layout(name="body", ratio=1)
)
layout["body"].split_row(
    Layout(name="datasets"),
    Layout(name="classes")
)

# 数据集信息表格
data_table = Table(title="[bold]CIFAR-10数据集信息[/bold]", box=box.ROUNDED, style="cyan")
data_table.add_column("数据集", style="cyan", header_style="bold")
data_table.add_column("样本数", style="green", header_style="bold")
data_table.add_column("批次数", style="yellow", header_style="bold")
data_table.add_column("批次大小", style="magenta", header_style="bold")
data_table.add_row("训练集", f"{len(train_data)}", f"{len(train_dataloader)}", "128")
data_table.add_row("测试集", f"{len(test_data)}", f"{len(test_dataloader)}", "100")

# 类别信息表格
class_table = Table(title="[bold]CIFAR-10类别信息[/bold]", box=box.ROUNDED, style="green")
class_table.add_column("类别序号", style="cyan", header_style="bold")
class_table.add_column("类别名称", style="green", header_style="bold")

for idx, class_name in enumerate(train_data.classes):
    class_table.add_row(f"{idx}", f"{class_name}")

# 填充布局
layout["header"].update(Panel(
    Text("CIFAR-10图像分类模型训练 (Adam优化器)", justify="center", style="bold white on blue"),
    box=box.ROUNDED,
    padding=(1, 1)
))
layout["datasets"].update(data_table)
layout["classes"].update(class_table)

# 显示布局
console.print(layout)

class AlexNet(nn.Module):
    """
    AlexNet模型定义 - 为CIFAR-10优化的版本
    """
    def __init__(self):
        super(AlexNet, self).__init__()
        self.features = Sequential(
            nn.Conv2d(3, 64, kernel_size=5, stride=1, padding=2),      # 第1卷积层
            nn.ReLU(inplace=True),                                     # ReLU激活函数
            nn.MaxPool2d(kernel_size=3, stride=2),                     # 第1池化层
            nn.Conv2d(64, 192, kernel_size=5, stride=1, padding=2),    # 第2卷积层
            nn.ReLU(inplace=True),                                     # ReLU激活函数
            nn.MaxPool2d(kernel_size=3, stride=2),                     # 第2池化层
            nn.Conv2d(192, 384, kernel_size=3, stride=1, padding=1),   # 第3卷积层
            nn.ReLU(inplace=True),                                     # ReLU激活函数
            nn.Conv2d(384, 256, kernel_size=3, stride=1, padding=1),   # 第4卷积层
            nn.ReLU(inplace=True),                                     # ReLU激活函数
            nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1),   # 第5卷积层
            nn.ReLU(inplace=True),                                     # ReLU激活函数
            nn.MaxPool2d(kernel_size=3, stride=2)                      # 第3池化层
        )
        self.classifier = nn.Sequential(
            nn.Linear(in_features=3 * 3 * 256, out_features=2048),     # 第1全连接层
            nn.ReLU(inplace=True),                                     # ReLU激活函数
            nn.Dropout(0.5),                                           # Dropout正则化
            nn.Linear(in_features=2048, out_features=1024),            # 第2全连接层
            nn.ReLU(inplace=True),                                     # ReLU激活函数
            nn.Dropout(0.5),                                           # Dropout正则化
            nn.Linear(1024, 10)                                        # 输出层
        )
        
        # 添加模型元数据
        self.metadata = {
            "name": "AlexNet-CIFAR10",
            "description": "针对CIFAR-10数据集优化的AlexNet变体",
            "input_size": (3, 32, 32),
            "num_classes": 10,
            "date_created": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

    def forward(self, x):
        x = self.features(x)           # 提取特征
        x = torch.flatten(x, 1)        # 将3D特征图展平为1D向量
        x = self.classifier(x)         # 分类
        return x

# 实例化模型
with console.status("[bold green]正在初始化AlexNet模型...", spinner="dots"):
    model = AlexNet().to(device)

# 显示模型结构信息
model_info = Panel(
    f"[bold green]AlexNet模型已初始化[/bold green]\n"
    f"[bold cyan]输入尺寸:[/bold cyan] [yellow]{model.metadata['input_size']}[/yellow]\n"
    f"[bold cyan]输出类别:[/bold cyan] [yellow]{model.metadata['num_classes']}[/yellow]\n"
    f"[bold cyan]模型描述:[/bold cyan] [yellow]{model.metadata['description']}[/yellow]",
    title="模型信息",
    border_style="green",
    box=box.ROUNDED
)
console.print(model_info)

# 定义损失函数和优化器
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001, betas=(0.9, 0.999), weight_decay=5e-4)
scheduler = optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=200)

# 创建保存模型的目录
os.makedirs("checkpoints", exist_ok=True)

# 设置TensorBoard
writer = SummaryWriter('logs/cifar10_alexnet_adam')

# 添加模型图到TensorBoard
dummy_input = torch.randn(1, 3, 32, 32).to(device)
writer.add_graph(model, dummy_input)

# 训练函数
def train(epoch, epoch_times):
    """
    训练一个epoch
    参数:
        epoch: 当前epoch索引
        epoch_times: 之前所有epoch的耗时列表
    """
    model.train()
    train_loss = 0
    correct = 0
    total = 0
    
    start_time = time.time()
    
    # 创建进度条
    progress_columns = [
        TextColumn("[bold blue]{task.description}"),
        BarColumn(bar_width=40, complete_style="green", finished_style="green"),
        TextColumn("[bold green]{task.completed}/{task.total}"),
        TextColumn("[bold yellow]{task.percentage:>3.0f}%"),
        TimeElapsedColumn(),
        TimeRemainingColumn(),
    ]
    
    # 计算已用时间和预计剩余时间
    elapsed_time = time.time() - train_start_time
    elapsed_str = str(datetime.timedelta(seconds=int(elapsed_time)))
    
    # 如果不是第一个epoch，则计算预计剩余时间
    if len(epoch_times) > 0:
        avg_epoch_time = sum(epoch_times) / len(epoch_times)
        remaining_epochs = num_epochs - epoch
        remaining_time = remaining_epochs * avg_epoch_time
        remaining_str = str(datetime.timedelta(seconds=int(remaining_time)))
    else:
        remaining_str = "计算中..."
    
    # 创建一个表格来显示当前的训练信息
    epoch_info = Table.grid(padding=1)
    epoch_info.add_row(
        f"[bold cyan]Epoch:[/bold cyan] [yellow]{epoch+1}/{num_epochs}[/yellow]",
        f"[bold cyan]已用时间:[/bold cyan] [yellow]{elapsed_str}[/yellow]",
        f"[bold cyan]预计剩余:[/bold cyan] [yellow]{remaining_str}[/yellow]",
        f"[bold cyan]学习率:[/bold cyan] [yellow]{optimizer.param_groups[0]['lr']:.6f}[/yellow]"
    )
                      
    # 使用Rich进度条显示训练进度
    with Progress(*progress_columns, console=console) as progress:
        console.print(epoch_info)
        task = progress.add_task(f"[cyan]训练 Epoch {epoch+1}[/cyan]", total=len(train_dataloader))
        
        for batch_idx, (inputs, targets) in enumerate(train_dataloader):
            inputs, targets = inputs.to(device), targets.to(device)
            
            # 梯度清零
            optimizer.zero_grad()
            
            # 前向传播
            outputs = model(inputs)
            loss = criterion(outputs, targets)
            
            # 反向传播和优化
            loss.backward()
            optimizer.step()
            
            # 统计
            train_loss += loss.item()
            _, predicted = outputs.max(1)
            total += targets.size(0)
            correct += predicted.eq(targets).sum().item()
            
            # 更新进度条描述，显示当前损失和准确率
            current_loss = train_loss / (batch_idx + 1)
            current_acc = 100. * correct / total
            progress.update(
                task, 
                advance=1, 
                description=f"[cyan]训练 Epoch {epoch+1}[/cyan] | 损失: {current_loss:.3f} | 准确率: {current_acc:.2f}%"
            )
            
            # 每100个批次记录一次详细信息
            if batch_idx % 100 == 0 and batch_idx > 0:
                # 记录梯度信息到TensorBoard
                for name, param in model.named_parameters():
                    if param.grad is not None:
                        writer.add_histogram(f'gradients/{name}', param.grad, epoch * len(train_dataloader) + batch_idx)
    
    acc = 100. * correct / total
    avg_loss = train_loss / len(train_dataloader)
    elapsed_time = time.time() - start_time
    
    # 记录到TensorBoard
    writer.add_scalar('训练/损失', avg_loss, epoch)
    writer.add_scalar('训练/准确率', acc, epoch)
    writer.add_scalar('训练/时间', elapsed_time, epoch)
    writer.add_scalar('训练/学习率', optimizer.param_groups[0]['lr'], epoch)
    
    # 记录权重和偏置分布
    for name, param in model.named_parameters():
        writer.add_histogram(f'权重/{name}', param, epoch)
    
    return avg_loss, acc, elapsed_time

# 测试函数
def test(epoch):
    """
    测试一个epoch
    参数:
        epoch: 当前epoch索引
    """
    model.eval()
    test_loss = 0
    correct = 0
    total = 0
    
    # 用于计算每类的准确率
    class_correct = [0] * 10
    class_total = [0] * 10
    
    # 使用进度条显示测试进度
    with Progress(
        TextColumn("[bold blue]{task.description}"),
        BarColumn(bar_width=40, complete_style="green", finished_style="green"),
        TextColumn("[bold green]{task.completed}/{task.total}"),
        TextColumn("[bold yellow]{task.percentage:>3.1f}%"),
        TimeElapsedColumn(),
        console=console
    ) as progress:
        task = progress.add_task(f"[cyan]测试 Epoch {epoch+1}[/cyan]", total=len(test_dataloader))
        
        with torch.no_grad():
            for batch_idx, (inputs, targets) in enumerate(test_dataloader):
                inputs, targets = inputs.to(device), targets.to(device)
                
                # 前向传播
                outputs = model(inputs)
                loss = criterion(outputs, targets)
                
                # 统计
                test_loss += loss.item()
                _, predicted = outputs.max(1)
                total += targets.size(0)
                correct += predicted.eq(targets).sum().item()
                
                # 计算每类的准确率
                c = predicted.eq(targets).cpu().numpy()
                for i in range(targets.size(0)):
                    label = targets[i].item()
                    class_correct[label] += c[i]
                    class_total[label] += 1
                
                # 更新进度条
                progress.update(task, advance=1)
    
    acc = 100. * correct / total
    avg_loss = test_loss / len(test_dataloader)
    
    # 创建测试结果表格
    test_table = Table(box=box.SIMPLE_HEAD, title="[bold]测试结果[/bold]")
    test_table.add_column("指标", style="cyan", header_style="bold")
    test_table.add_column("值", style="green", header_style="bold")
    test_table.add_row("损失", f"{avg_loss:.4f}")
    test_table.add_row("准确率", f"{acc:.2f}%")
    
    console.print(test_table)
    
    # 创建每类准确率表格
    class_acc_table = Table(box=box.SIMPLE_HEAD, title="[bold]各类别准确率[/bold]")
    class_acc_table.add_column("类别ID", style="cyan", header_style="bold")
    class_acc_table.add_column("类别名称", style="green", header_style="bold")
    class_acc_table.add_column("准确率", style="yellow", header_style="bold")
    
    for i in range(10):
        if class_total[i] > 0:
            class_acc = 100. * class_correct[i] / class_total[i]
            class_acc_table.add_row(
                f"{i}", 
                f"{train_data.classes[i]}", 
                f"{class_acc:.2f}%"
            )
    
    console.print(class_acc_table)
    
    # 记录到TensorBoard
    writer.add_scalar('测试/损失', avg_loss, epoch)
    writer.add_scalar('测试/准确率', acc, epoch)
    
    # 记录每类准确率
    for i in range(10):
        if class_total[i] > 0:
            writer.add_scalar(f'测试/类别准确率/{train_data.classes[i]}', 
                              100. * class_correct[i] / class_total[i], 
                              epoch)
    
    return avg_loss, acc

# 训练和测试循环
num_epochs = 50
best_acc = 0
epoch_times = []  # 存储每个epoch的时间
train_start_time = time.time()  # 训练开始时间

# 美化的训练开始信息
console.print(Panel(
    f"[bold green]开始训练:[/bold green] {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
    f"[bold cyan]计划训练:[/bold cyan] {num_epochs} 个epochs\n"
    f"[bold cyan]优化器:[/bold cyan] Adam (学习率=0.001, beta1=0.9, beta2=0.999, 权重衰减=5e-4)\n"
    f"[bold cyan]学习率调度:[/bold cyan] 余弦退火 (T_max=200)",
    title="训练配置",
    border_style="green",
    box=box.ROUNDED
))

for epoch in range(num_epochs):
    epoch_start_time = time.time()
    
    # 使用更漂亮的分隔线
    console.rule(f"[bold cyan]Epoch {epoch+1}/{num_epochs}[/bold cyan]", style="cyan")
    
    # 训练一个epoch
    train_loss, train_acc, epoch_train_time = train(epoch, epoch_times)
    
    # 测试一个epoch
    test_loss, test_acc = test(epoch)
    
    # 调整学习率
    old_lr = optimizer.param_groups[0]['lr']
    scheduler.step()
    new_lr = optimizer.param_groups[0]['lr']
    
    # 记录本epoch的时间
    epoch_time = time.time() - epoch_start_time
    epoch_times.append(epoch_time)
    
    # 计算平均epoch时间和预计剩余时间
    avg_epoch_time = sum(epoch_times) / len(epoch_times)
    remaining_epochs = num_epochs - (epoch + 1)
    remaining_time = remaining_epochs * avg_epoch_time
    
    # 格式化时间显示
    epoch_time_str = str(datetime.timedelta(seconds=int(epoch_time)))
    avg_time_str = str(datetime.timedelta(seconds=int(avg_epoch_time)))
    remaining_str = str(datetime.timedelta(seconds=int(remaining_time)))
    elapsed_str = str(datetime.timedelta(seconds=int(time.time() - train_start_time)))
    
    # 创建Epoch结束信息表格
    summary_table = Table(box=box.SIMPLE_HEAD, title="[bold]本轮结果[/bold]")
    summary_table.add_column("指标", style="cyan", header_style="bold")
    summary_table.add_column("训练集", style="green", header_style="bold")
    summary_table.add_column("测试集", style="yellow", header_style="bold")
    
    summary_table.add_row("损失", f"{train_loss:.4f}", f"{test_loss:.4f}")
    summary_table.add_row("准确率", f"{train_acc:.2f}%", f"{test_acc:.2f}%")
    summary_table.add_row("学习率", f"{old_lr:.6f} → {new_lr:.6f}", "")
    
    time_table = Table(box=box.SIMPLE_HEAD, title="[bold]时间统计[/bold]")
    time_table.add_column("当前耗时", style="cyan", header_style="bold")
    time_table.add_column("平均耗时", style="green", header_style="bold")
    time_table.add_column("已训练时间", style="yellow", header_style="bold")
    time_table.add_column("预计剩余", style="magenta", header_style="bold")
    
    time_table.add_row(
        epoch_time_str,
        avg_time_str,
        elapsed_str,
        remaining_str
    )
    
    console.print(summary_table)
    console.print(time_table)
    
    # 保存最佳模型
    if test_acc > best_acc:
        best_acc = test_acc
        torch.save({
            'epoch': epoch,
            'model_state_dict': model.state_dict(),
            'optimizer_state_dict': optimizer.state_dict(),
            'scheduler_state_dict': scheduler.state_dict(),
            'accuracy': best_acc,
            'loss': test_loss,
            'date': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }, f'checkpoints/alexnet_cifar10_adam_best.pth')
        console.print(f"[bold green]保存最佳模型! 准确率: {best_acc:.2f}%[/bold green]")
    
    # 每10个epoch保存一个checkpoint
    if (epoch + 1) % 10 == 0:
        torch.save({
            'epoch': epoch,
            'model_state_dict': model.state_dict(),
            'optimizer_state_dict': optimizer.state_dict(),
            'scheduler_state_dict': scheduler.state_dict(),
            'best_acc': best_acc,
            'date': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }, f'checkpoints/alexnet_cifar10_adam_epoch_{epoch+1}.pth')
        console.print(f"[bold blue]保存Checkpoint: Epoch {epoch+1}[/bold blue]")

# 计算总训练时间
total_time = time.time() - train_start_time
total_time_str = str(datetime.timedelta(seconds=int(total_time)))

# 关闭TensorBoard writer
writer.close()

# 训练结束信息面板
final_panel = Panel(
    f"[bold green]训练完成![/bold green]\n"
    f"[bold cyan]最佳测试精度:[/bold cyan] [yellow]{best_acc:.2f}%[/yellow]\n"
    f"[bold cyan]总训练时间:[/bold cyan] [yellow]{total_time_str}[/yellow]\n"
    f"[bold cyan]结束时间:[/bold cyan] [yellow]{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}[/yellow]\n"
    f"[bold cyan]TensorBoard:[/bold cyan] [yellow]运行 'tensorboard --logdir=logs' 查看训练详情[/yellow]\n"
    f"[bold cyan]模型保存位置:[/bold cyan] [yellow]checkpoints/alexnet_cifar10_adam_best.pth[/yellow]",
    title="训练总结",
    border_style="green",
    box=box.ROUNDED
)

console.print(final_panel)

# 导出模型为ONNX格式以供可视化
output_path = 'alexnet_cifar10_adam_netron.onnx'
console.print(f"[bold cyan]正在导出ONNX模型用于可视化...[/bold cyan]")

try:
    dummy_input = torch.randn(1, 3, 32, 32).to(device)
    torch.onnx.export(
        model,
        dummy_input,
        output_path,
        export_params=True,
        opset_version=11,
        do_constant_folding=True,
        input_names=["图像输入"],
        output_names=["分类输出"],
        dynamic_axes={
            "图像输入": {0: "批次大小"},
            "分类输出": {0: "批次大小"}
        }
    )
    console.print(f"[bold green]模型已导出为ONNX格式: {output_path}[/bold green]")
    console.print(f"[bold yellow]提示: 使用Netron查看模型结构: https://netron.app/[/bold yellow]")
except Exception as e:
    console.print(f"[bold red]导出ONNX模型时出错: {e}[/bold red]")

```



# 3.assignment3

























































